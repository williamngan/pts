// Generated by dts-bundle v0.7.3

export {};

export {};

/**
    * Bound is a subclass of Group that represents a rectangular boundary.
    * It includes some convenient properties such as `x`, `y`, bottomRight`, `center`, and `size`.
    */
export class Bound extends Group implements IPt {
        protected _center: Pt;
        protected _size: Pt;
        protected _topLeft: Pt;
        protected _bottomRight: Pt;
        protected _inited: boolean;
        /**
            * Create a Bound. This is similar to the Group constructor.
            * @param args a list of Pt as parameters
            */
        constructor(...args: Pt[]);
        /**
            * Create a Bound from a [ClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) object.
            * @param rect an object has top/left/bottom/right/width/height properties
            * @returns a Bound object
            */
        static fromBoundingRect(rect: ClientRect): Bound;
        static fromGroup(g: GroupLike): Bound;
        /**
            * Initiate the bound's properties.
            */
        protected init(): void;
        /**
            * Clone this bound and return a new one
            */
        clone(): Bound;
        /**
            * Recalculte size and center
            */
        protected _updateSize(): void;
        /**
            * Recalculate center
            */
        protected _updateCenter(): void;
        /**
            * Recalculate based on top-left position and size
            */
        protected _updatePosFromTop(): void;
        /**
            * Recalculate based on bottom-right position and size
            */
        protected _updatePosFromBottom(): void;
        /**
            * Recalculate based on center position and size
            */
        protected _updatePosFromCenter(): void;
        size: Pt;
        center: Pt;
        topLeft: Pt;
        bottomRight: Pt;
        width: number;
        height: number;
        depth: number;
        readonly x: number;
        readonly y: number;
        readonly z: number;
        readonly inited: boolean;
        /**
            * If the Group elements are changed, call this function to update the Bound's properties.
            * It's preferable to change the topLeft/bottomRight etc properties instead of changing the Group array directly.
            */
        update(): this;
}

export interface PtsCanvasRenderingContext2D extends CanvasRenderingContext2D {
        webkitBackingStorePixelRatio?: number;
        mozBackingStorePixelRatio?: number;
        msBackingStorePixelRatio?: number;
        oBackingStorePixelRatio?: number;
        backingStorePixelRatio?: number;
}
/**
 * CanvasSpace is an implementation of the abstract class Space. It represents a space for HTML Canvas.
 * Learn more about the concept of Space in [this guide](..guide/Space-0500.html)
 */
export class CanvasSpace extends MultiTouchSpace {
        protected _canvas: HTMLCanvasElement;
        protected _container: Element;
        protected _pixelScale: number;
        protected _autoResize: boolean;
        protected _bgcolor: string;
        protected _ctx: PtsCanvasRenderingContext2D;
        protected _offscreen: boolean;
        protected _offCanvas: HTMLCanvasElement;
        protected _offCtx: PtsCanvasRenderingContext2D;
        protected _initialResize: boolean;
        /**
         * Create a CanvasSpace which represents a HTML Canvas Space
         * @param elem Specify an element by its "id" attribute as string, or by the element object itself. An element can be an existing `<canvas>`, or a `<div>` container in which a new `<canvas>` will be created. If left empty, a `<div id="pt_container"><canvas id="pt" /></div>` will be added to DOM. Use css to customize its appearance if needed.
         * @param callback an optional callback `function(boundingBox, spaceElement)` to be called when canvas is appended and ready. Alternatively, a "ready" event will also be fired from the `<canvas>` element when it's appended, which can be traced with `spaceInstance.canvas.addEventListener("ready")`
         * @example `new CanvasSpace( "#myElementID" )`
         */
        constructor(elem: string | Element, callback?: Function);
        /**
         * Helper function to create a DOM element
         * @param elem element tag name
         * @param id element id attribute
         */
        protected _createElement(elem: string, id: any): HTMLElement;
        /**
         * Set up various options for CanvasSpace. The `opt` parameter is an object with the following fields. This is usually set during instantiation, eg `new CanvasSpace(...).setup( { opt } )`
         * @param opt an object with optional settings, as follows.
         * @param opt.bgcolor a hex or rgba string to set initial background color of the canvas, or use `false` or "transparent" to set a transparent background. You may also change it later with `clear()`
         * @param opt.resize a boolean to set whether `<canvas>` size should auto resize to match its container's size. You can also set it manually with `autoSize()`
         * @param opt.retina a boolean to set if device pixel scaling should be used. This may make drawings on retina displays look sharper but may reduce performance slightly. Default is `true`.
         * @param opt.offscreen a boolean to set if a duplicate canvas should be created for offscreen rendering. Default is `false`.
         * @example `space.setup({ bgcolor: "#f00", retina: true, resize: true })`
         */
        setup(opt: {
                bgcolor?: string;
                resize?: boolean;
                retina?: boolean;
                offscreen?: boolean;
        }): this;
        /**
         * Set whether the canvas element should resize when its container is resized.
         * @param auto a boolean value indicating if auto size is set
         */
        autoResize: boolean;
        /**
     * This overrides Space's `resize` function. It's used as a callback function for window's resize event and not usually called directly. You can keep track of resize events with `resize: (bound ,evt)` callback in your player objects (See `Space`'s `add()` function).
     * @param b a Bound object to resize to
     * @param evt Optionally pass a resize event
     */
        resize(b: Bound, evt?: Event): this;
        /**
         * Window resize handling
         * @param evt
         */
        protected _resizeHandler(evt: Event): void;
        /**
         * Set a background color for this canvas. Alternatively, you may use `clear()` function.
        @param bg background color as hex or rgba string
         */
        background: string;
        /**
         * `pixelScale` property returns a number that let you determine if the screen is "retina" (when value >= 2)
         */
        readonly pixelScale: number;
        /**
         * Check if an offscreen canvas is created
         */
        readonly hasOffscreen: boolean;
        /**
         * Get the rendering context of offscreen canvas (if created via `setup()`)
         */
        readonly offscreenCtx: PtsCanvasRenderingContext2D;
        /**
         * Get the offscreen canvas element
         */
        readonly offscreenCanvas: HTMLCanvasElement;
        /**
         * Get a new `CanvasForm` for drawing
         * @see `CanvasForm`
         */
        getForm(): CanvasForm;
        /**
         * Get the html canvas element
         */
        readonly element: HTMLCanvasElement;
        /**
         * Get the parent element that contains the canvas element
         */
        readonly parent: Element;
        /**
            * A property to indicate if the Space is ready
            */
        readonly ready: boolean;
        /**
         * Get the rendering context of canvas
         */
        readonly ctx: PtsCanvasRenderingContext2D;
        /**
         * Clear the canvas with its background color. Overrides Space's `clear` function.
         * @param bg Optionally specify a custom background color in hex or rgba string, or "transparent". If not defined, it will use its `bgcolor` property as background color to clear the canvas.
         */
        clear(bg?: string): this;
        /**
         * Similiar to `clear()` but clear the offscreen canvas instead
         * @param bg Optionally specify a custom background color in hex or rgba string, or "transparent". If not defined, it will use its `bgcolor` property as background color to clear the canvas.
         */
        clearOffscreen(bg?: string): this;
        /**
         * Main animation function. Call `Space.playItems`.
         * @param time current time
         */
        protected playItems(time: number): void;
}
/**
 * CanvasForm is an implementation of abstract class VisualForm. It provide methods to express Pts on CanvasSpace.
 * You may extend CanvasForm to implement your own expressions for CanvasSpace.
 */
export class CanvasForm extends VisualForm {
        protected _space: CanvasSpace;
        protected _ctx: CanvasRenderingContext2D;
        protected _estimateTextWidth: (string) => number;
        /**
         * store common styles so that they can be restored to canvas context when using multiple forms. See `reset()`.
         */
        protected _style: {
                fillStyle: string;
                strokeStyle: string;
                lineWidth: number;
                lineJoin: string;
                lineCap: string;
        };
        /**
         * Create a new CanvasForm. You may also use `space.getForm()` to get the default form.
         * @param space an instance of CanvasSpace
         */
        constructor(space: CanvasSpace);
        /**
         * get the CanvasSpace instance that this form is associated with
         */
        readonly space: CanvasSpace;
        /**
         * Toggle whether to draw on offscreen canvas (if offscreen is set in CanvasSpace)
         * @param off if `true`, draw on offscreen canvas instead of the visible canvas. Default is `true`
         * @param clear optionally provide a valid color string to fill a bg color. see CanvasSpace's `clearOffscreen` function.
         */
        useOffscreen(off?: boolean, clear?: boolean | string): this;
        /**
         * Render the offscreen canvas's content on the visible canvas
         * @param offset Optional offset on the top-left position when drawing on the visible canvas
         */
        renderOffscreen(offset?: PtLike): void;
        /**
         * Set current fill style. Provide a valid color string or `false` to specify no fill color.
         * @example `form.fill("#F90")`, `form.fill("rgba(0,0,0,.5")`, `form.fill(false)`
         * @param c fill color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle))
         */
        fill(c: string | boolean): this;
        /**
         * Set current stroke style. Provide a valid color string or `false` to specify no stroke color.
         * @example `form.stroke("#F90")`, `form.stroke("rgba(0,0,0,.5")`, `form.stroke(false)`, `form.stroke("#000", 0.5, 'round', 'square')`
         * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle))
         * @param width Optional value (can be floating point) to set line width
         * @param linejoin Optional string to set line joint style. Can be "miter", "bevel", or "round".
         * @param linecap Optional string to set line cap style. Can be "butt", "round", or "square".
         */
        stroke(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
         * Set the current font
         * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties
         * @param weight Optional font-weight string such as "bold"
         * @param style Optional font-style string such as "italic"
         * @param lineHeight Optional line-height number suchas 1.5
         * @param family Optional font-family such as "Helvetica, sans-serif"
         * @example `form.font( myFont )`, `form.font(14, "bold")`
         */
        font(sizeOrFont: number | Font, weight?: string, style?: string, lineHeight?: number, family?: string): this;
        /**
            * Set whether to use ctx.measureText or a faster but less accurate heuristic function.
            * @param estimate `true` to use heuristic function, or `false` to use ctx.measureText
            */
        fontWidthEstimate(estimate?: boolean): this;
        /**
            * Get the width of this text. It will return an actual measurement or an estimate based on `fontWidthEstimate` setting. Default is an actual measurement using canvas context's measureText.
            * @param c a string of text contents
            */
        getTextWidth(c: string): number;
        /**
            * Truncate text to fit width
            * @param str text to truncate
            * @param width width to fit
            * @param tail text to indicate overflow such as "...". Default is empty "".
            */
        protected _textTruncate(str: string, width: number, tail?: string): [string, number];
        /**
            * Align text within a rectangle box
            * @param box a Group that defines a rectangular box
            * @param vertical a string that specifies the vertical alignment in the box: "top", "bottom", "middle", "start", "end"
            * @param offset Optional offset from the edge (like padding)
            * @param center Optional center position
            */
        protected _textAlign(box: GroupLike, vertical: string, offset?: PtLike, center?: Pt): Pt;
        /**
         * Reset the rendering context's common styles to this form's styles. This supports using multiple forms on the same canvas context.
         */
        reset(): this;
        protected _paint(): void;
        /**
         * Draws a point
         * @param p a Pt object
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         * @example `form.point( p )`, `form.point( p, 10, "circle" )`
         */
        point(p: PtLike, radius?: number, shape?: string): this;
        /**
         * A static function to draw a circle
         * @param ctx canvas rendering context
         * @param pt center position of the circle
         * @param radius radius of the circle
         */
        static circle(ctx: CanvasRenderingContext2D, pt: PtLike, radius?: number): void;
        /**
         * Draw a circle
         * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]
         * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)
         */
        circle(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw an arc.
         * @param ctx canvas rendering context
         * @param pt center position
         * @param radius radius of the arc circle
         * @param startAngle start angle of the arc
         * @param endAngle end angle of the arc
         * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
         */
        static arc(ctx: CanvasRenderingContext2D, pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): void;
        /**
         * Draw an arc.
         * @param pt center position
         * @param radius radius of the arc circle
         * @param startAngle start angle of the arc
         * @param endAngle end angle of the arc
         * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
         */
        arc(pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): this;
        /**
         * A static function to draw a square
         * @param ctx canvas rendering context
         * @param pt center position of the square
         * @param halfsize half size of the square
         */
        static square(ctx: CanvasRenderingContext2D, pt: PtLike, halfsize: number): void;
        /**
            * Draw a square, given a center and its half-size
            * @param pt center Pt
            * @param halfsize half-size
            */
        square(pt: PtLike, halfsize: number): this;
        /**
         * A static function to draw a line
         * @param ctx canvas rendering context
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        static line(ctx: CanvasRenderingContext2D, pts: GroupLike | number[][]): void;
        /**
         * Draw a line or polyline
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        line(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw polygon
         * @param ctx canvas rendering context
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        static polygon(ctx: CanvasRenderingContext2D, pts: GroupLike | number[][]): void;
        /**
         * Draw a polygon
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        polygon(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw a rectangle
         * @param ctx canvas rendering context
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        static rect(ctx: CanvasRenderingContext2D, pts: GroupLike | number[][]): void;
        /**
         * Draw a rectangle
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        rect(pts: number[][] | Pt[]): this;
        /**
         * A static function to draw text
         * @param ctx canvas rendering context
         * @param `pt` a Point object to specify the anchor point
         * @param `txt` a string of text to draw
         * @param `maxWidth` specify a maximum width per line
         */
        static text(ctx: CanvasRenderingContext2D, pt: PtLike, txt: string, maxWidth?: number): void;
        /**
         * Draw text on canvas
         * @param `pt` a Pt or numeric array to specify the anchor point
         * @param `txt` text
         * @param `maxWidth` specify a maximum width per line
         */
        text(pt: PtLike, txt: string, maxWidth?: number): this;
        /**
            * Fit a single-line text in a rectangular box
            * @param box a rectangle box defined by a Group
            * @param txt string of text
            * @param tail text to indicate overflow such as "...". Default is empty "".
            * @param verticalAlign "top", "middle", or "bottom" to specify vertical alignment inside the box
            * @param overrideBaseline If `true`, use the corresponding baseline as verticalAlign. If `false`, use the current canvas context's textBaseline setting. Default is `true`.
            */
        textBox(box: GroupLike, txt: string, verticalAlign?: string, tail?: string, overrideBaseline?: boolean): this;
        /**
            * Fit multi-line text in a rectangular box. Note that this will also set canvas context's textBaseline to "top".
            * @param box a rectangle box defined by a Group
            * @param txt string of text
            * @param lineHeight line height as a ratio of font size. Default is 1.2.
            * @param verticalAlign "top", "middle", or "bottom" to specify vertical alignment inside the box
            * @param crop a boolean to specify whether to crop text when overflowing
            */
        paragraphBox(box: GroupLike, txt: string, lineHeight?: number, verticalAlign?: string, crop?: boolean): this;
        /**
            * Set text alignment and baseline (eg, vertical-align)
            * @param alignment Canvas' textAlign option: "left", "right", "center", "start", or "end"
            * @param baseline Canvas' textBaseline option: "top", "hanging", "middle", "alphabetic", "ideographic", "bottom". For convenience, you can also use "center" (same as "middle"), and "baseline" (same as "alphabetic")
            */
        alignText(alignment?: string, baseline?: string): this;
        /**
         * A convenient way to draw some text on canvas for logging or debugging. It'll be draw on the top-left of the canvas as an overlay.
         * @param txt text
         */
        log(txt: any): this;
}

export type ColorType = "rgb" | "hsl" | "hsb" | "lab" | "lch" | "luv" | "xyz";
/**
    * Color is a subclass of Pt. You can think of a color as a point in a color space. The Color class provides support for many color spaces.
    */
export class Color extends Pt {
        protected _mode: ColorType;
        /**
            * Value range for each color space
            */
        static ranges: {
                [name: string]: Group;
        };
        /**
            * Create a Color. Same as creating a Pt.
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        constructor(...args: any[]);
        /**
            * Create a Color object with defaults to 4 dimensions
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        static from(...args: any[]): Color;
        /**
            * Convert a rgb hex string like #FF0000 or #F00 to a Color object
            * @param hex a hex string, with optional '#' prefix
            */
        static fromHex(hex: string): Color;
        /**
            * Create RGB Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static rgb(...args: any[]): Color;
        /**
            * Create HSL Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static hsl(...args: any[]): Color;
        /**
            * Create HSB Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static hsb(...args: any[]): Color;
        /**
            * Create LAB Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static lab(...args: any[]): Color;
        /**
            * Create LCH Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static lch(...args: any[]): Color;
        /**
            * Create LUV Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static luv(...args: any[]): Color;
        /**
            * Create XYZ Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static xyz(...args: any[]): Color;
        /**
            * Get a Color object whose values are the maximum of its mode
            * @param mode a mode string such as "rgb" or "lab"
            * @example Color.maxValue("rgb") will return a rgb Color object with values (255,255,255)
            */
        static maxValues(mode: string): Pt;
        /**
            * Get a hex string such as "#FF0000". Same as `toString("hex")`
            */
        readonly hex: string;
        /**
            * Get a rgb string such as "rgb(255,0,0)". Same as `toString("rgb")`
            */
        readonly rgb: string;
        /**
            * Get a rgba string such as "rgb(255,0,0,0.5)". Same as `toString("rgba")`
            */
        readonly rgba: string;
        /**
            * Clone this Color
            */
        clone(): Color;
        /**
            * Convert this color from current color space to another color space
            * @param mode a ColorType string: "rgb" "hsl" "hsb" "lab" "lch" "luv" "xyz";
            * @param convert if `true`, convert this Color to the new color space specified in `mode`. Default is `false`, which only sets the color mode without converting color values.
            */
        toMode(mode: ColorType, convert?: boolean): this;
        /**
            * Get this Color's mode
            */
        readonly mode: ColorType;
        r: number;
        g: number;
        b: number;
        h: number;
        s: number;
        l: number;
        a: number;
        c: number;
        u: number;
        v: number;
        /**
            * Get alpha value
            */
        readonly alpha: number;
        /**
            * Normalize the color values to between 0 to 1, or revert it back to the min/max values in current color mode
            * @param toNorm a boolean value specifying whether to normalize (`true`) or revert (`false`)
            */
        normalize(toNorm?: boolean): Color;
        /**
            * Like `normalize()` but returns as a new Color
            * @param toNorm a boolean value specifying whether to normalize (`true`) or revert (`false`)
            * @returns new Color
            */
        $normalize(toNorm?: boolean): Color;
        /**
            * Convert this Color to a string. It can be used to get a hex or rgb string for use in rendering
            * @param format "hex", "rgb", "rgba", or "mode" which means using current color mode label. Default is "mode".
            */
        toString(format?: ("hex" | "rgb" | "rgba" | "mode")): string;
        /**
            * Convert RGB to HSL
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new HSL Color
            */
        static RGBtoHSL(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert HSL to RGB
            * @param hsl a HSL Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static HSLtoRGB(hsl: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert RGB to HSB
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new HSB Color
            */
        static RGBtoHSB(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert HSB to RGB
            * @param hsb a HSB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static HSBtoRGB(hsb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
        * Convert RGB to LAB
        * @param rgb a RGB Color
        * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
        * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
        * @returns a new LAB Color
        */
        static RGBtoLAB(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LAB to RGB
            * @param lab a LAB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static LABtoRGB(lab: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert RGB to LCH
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LCH Color
            */
        static RGBtoLCH(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LCH to RGB
            * @param lch a LCH Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static LCHtoRGB(lch: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert RGB to LUV
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LUV Color
            */
        static RGBtoLUV(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LUV to RGB
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static LUVtoRGB(luv: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert RGB to XYZ
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new XYZ Color
            */
        static RGBtoXYZ(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert XYZ to RGB
            * @param xyz a XYZ Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static XYZtoRGB(xyz: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert XYZ to LAB
            * @param xyz a XYZ Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LAB Color
            */
        static XYZtoLAB(xyz: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LAB to XYZ
            * @param lab a LAB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new XYZ Color
            */
        static LABtoXYZ(lab: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert XYZ to LUV
            * @param xyz a XYZ Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LUV Color
            */
        static XYZtoLUV(xyz: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LUV to XYZ
            * @param luv a LUV Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new XYZ Color
            */
        static LUVtoXYZ(luv: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LAB to LCH
            * @param lab a LAB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LCH Color
            */
        static LABtoLCH(lab: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LCH to LAB
            * @param lch a LCH Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LAB Color
            */
        static LCHtoLAB(lch: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
}

/**
    * The `Create` class provides various convenient functions to create structures or shapes.
    */
export class Create {
        /**
            * Create a set of random points inside a bounday
            * @param bound the rectangular boundary
            * @param count number of random points to create
            * @param dimensions number of dimensions in each point
            */
        static distributeRandom(bound: Bound, count: number, dimensions?: number): Group;
        /**
            * Create a set of points that distribute evenly on a line
            * @param line a Group representing a line
            * @param count number of points to create
            */
        static distributeLinear(line: GroupLike, count: number): Group;
        /**
            * Create an evenly distributed set of points (like a grid of points) inside a boundary.
            * @param bound the rectangular boundary
            * @param columns number of columns
            * @param rows number of rows
            * @param orientation a Pt or number array to specify where the point should be inside a cell. Default is [0.5, 0.5] which places the point in the middle.
            * @returns a Group of Pts
            */
        static gridPts(bound: Bound, columns: number, rows: number, orientation?: PtLike): Group;
        /**
            * Create a grid inside a boundary
            * @param bound the rectangular boundary
            * @param columns number of columns
            * @param rows number of rows
            * @returns an array of Groups, where each group represents a rectangular cell
            */
        static gridCells(bound: Bound, columns: number, rows: number): Group[];
        /**
            * Create a set of Pts around a circular path
            * @param center circle center
            * @param radius circle radius
            * @param count number of Pts to create
            */
        static radialPts(center: PtLike, radius: number, count: number): Group;
        /**
            * Given a group of Pts, return a new group of `Noise` Pts.
            * @param pts a Group or an array of Pts
            * @param dx small increment value in x dimension
            * @param dy small increment value in y dimension
            * @param rows Optional row count to generate 2D noise
            * @param columns Optional column count to generate 2D noise
            */
        static noisePts(pts: GroupLike, dx?: number, dy?: number, rows?: number, columns?: number): Group;
        /**
            * Create a Delaunay Group. Use the `.delaunay()` and `.voronoi()` functions in the returned group to generate tessellations.
            * @param pts a Group or an array of Pts
            * @returns an instance of the Delaunay class
            */
        static delaunay(pts: GroupLike): Delaunay;
}
/**
    * A class to generate Perlin noise. Currently it implements a basic 2D noise. More to follow.
    * Based on https://gist.github.com/banksean/304522
    */
export class Noise extends Pt {
        protected perm: number[];
        /**
            * Create a Noise Pt that's capable of generating noise
            * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        constructor(...args: any[]);
        /**
            * Set the initial noise values
            * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            * @example `noise.initNoise( 0.01, 0.1 )`
            */
        initNoise(...args: any[]): void;
        /**
            * Add a small increment to the noise values
            * @param x step in x dimension
            * @param y step in y dimension
            */
        step(x?: number, y?: number): void;
        /**
            * Specify a seed for this Noise
            * @param s seed value
            */
        seed(s: any): void;
        /**
            * Generate a 2D Perlin noise value
            */
        noise2D(): number;
}
/**
    * A DelaunayShape is an object with 3 indices, a Triangle Group and a Circle Group.
    */
export type DelaunayShape = {
        i: number;
        j: number;
        k: number;
        triangle: GroupLike;
        circle: Group;
};
export type DelaunayMesh = {
        [key: string]: DelaunayShape;
}[];
/**
    * Delaunay is a Group of Pts that can generate Delaunay and Voronoi tessellations. The triangulation algorithm is ported from [Pt](https://github.com/williamngan/pt)
    * This implementation is based on [Paul Bourke's algorithm](http://paulbourke.net/papers/triangulate/)
    * with reference to its [javascript implementation by ironwallaby](https://github.com/ironwallaby/delaunay)
    */
export class Delaunay extends Group {
        /**
            * Generate Delaunay triangles. This function also caches the mesh that is used to generate Voronoi tessellation in `voronoi()`.
            * @param triangleOnly if true, returns an array of triangles in Groups, otherwise return the whole DelaunayShape
            * @returns an array of Groups or an array of DelaunayShapes `{i, j, k, triangle, circle}` which records the indices of the vertices, and the calculated triangles and circumcircles
            */
        delaunay(triangleOnly?: boolean): GroupLike[] | DelaunayShape[];
        /**
            * Generate Voronoi cells. `delaunay()` must be called before calling this function.
            * @returns an array of Groups, each of which represents a Voronoi cell
            */
        voronoi(): Group[];
        /**
            * Get the cached mesh. The mesh is an array of objects, each of which representing the enclosing triangles around a Pt in this Delaunay group
            * @return an array of objects that store a series of DelaunayShapes
            */
        mesh(): DelaunayMesh;
        /**
            * Given an index of a Pt in this Delaunay Group, returns its neighboring Pts in the network
            * @param i index of a Pt
            * @param sort if true, sort the neighbors so that their edges will form a polygon
            * @returns an array of Pts
            */
        neighborPts(i: number, sort?: boolean): GroupLike;
        /**
            * Given an index of a Pt in this Delaunay Group, returns its neighboring DelaunayShapes
            * @param i index of a Pt
            * @returns an array of DelaunayShapes `{i, j, k, triangle, circle}`
            */
        neighbors(i: number): DelaunayShape[];
        /**
            * Record a DelaunayShape in the mesh
            * @param o DelaunayShape instance
            */
        protected _cache(o: any): void;
        /**
            * Get the initial "super triangle" that contains all the points in this set
            * @returns a Group representing a triangle
            */
        protected _superTriangle(): Group;
        /**
            * Get a triangle from 3 points in a list of points
            * @param i index 1
            * @param j index 2
            * @param k index 3
            * @param pts a Group of Pts
            */
        protected _triangle(i: number, j: number, k: number, pts?: GroupLike): Group;
        /**
            * Get a circumcircle and triangle from 3 points in a list of points
            * @param i index 1
            * @param j index 2
            * @param k index 3
            * @param tri a Group representing a triangle, or `false` to create it from indices
            * @param pts a Group of Pts
            */
        protected _circum(i: number, j: number, k: number, tri: GroupLike | false, pts?: GroupLike): DelaunayShape;
        /**
            * Dedupe the edges array
            * @param edges
            */
        protected static _dedupe(edges: number[]): number[];
}

/**
    * A type that represents the current context for an DOMForm
    */
export type DOMFormContext = {
        group: Element;
        groupID: string;
        groupCount: number;
        currentID: string;
        currentClass?: string;
        style: object;
        font: string;
        fontSize: number;
        fontFamily: string;
};
/**
    * A Space for DOM elements
    */
export class DOMSpace extends MultiTouchSpace {
        protected _canvas: HTMLElement | SVGElement;
        protected _container: Element;
        id: string;
        protected _autoResize: boolean;
        protected _bgcolor: string;
        protected _css: {};
        /**
         * Create a DOMSpace which represents a Space for DOM elements
         * @param elem Specify an element by its "id" attribute as string, or by the element object itself. Use css to customize its appearance if needed.
         * @param callback an optional callback `function(boundingBox, spaceElement)` to be called when canvas is appended and ready. Alternatively, a "ready" event will also be fired from the element when it's appended, which can be traced with `spaceInstance.canvas.addEventListener("ready")`
         * @example `new DOMSpace( "#myElementID" )`
         */
        constructor(elem: string | Element, callback?: Function);
        /**
         * Helper function to create a DOM element
         * @param elem element tag name
         * @param id element id attribute
         * @param appendTo Optional, if specified, the created element will be appended to this element
         */
        static createElement(elem: string, id: string, appendTo?: Element): Element;
        /**
         * Set up various options for DOMSpace. The `opt` parameter is an object with the following fields. This is usually set during instantiation, eg `new DOMSpace(...).setup( { opt } )`
         * @param opt an object with optional settings, as follows.
         * @param opt.bgcolor a hex or rgba string to set initial background color of the canvas, or use `false` or "transparent" to set a transparent background. You may also change it later with `clear()`
         * @param opt.resize a boolean to set whether `<canvas>` size should auto resize to match its container's size. You can also set it manually with `autoSize()`
         * @example `space.setup({ bgcolor: "#f00", resize: true })`
         */
        setup(opt: {
                bgcolor?: string;
                resize?: boolean;
        }): this;
        /**
            * Not implemented. See SVGSpace and HTMLSpace for implementation
            */
        getForm(): Form;
        /**
         * Set whether the canvas element should resize when its container is resized.
         * @param auto a boolean value indicating if auto size is set
         */
        autoResize: boolean;
        /**
         * This overrides Space's `resize` function. It's used as a callback function for window's resize event and not usually called directly. You can keep track of resize events with `resize: (bound ,evt)` callback in your player objects (See `Space`'s `add()` function).
         * @param b a Bound object to resize to
         * @param evt Optionally pass a resize event
         */
        resize(b: Bound, evt?: Event): this;
        /**
         * Window resize handling
         * @param evt
         */
        protected _resizeHandler(evt: Event): void;
        /**
         * Get this DOM element
         */
        readonly element: Element;
        /**
         * Get the parent DOM element that contains this DOM element
         */
        readonly parent: Element;
        /**
         * A property to indicate if the Space is ready
         */
        readonly ready: boolean;
        /**
         * Clear the element's contents, and ptionally set a new backgrounc color. Overrides Space's `clear` function.
         * @param bg Optionally specify a custom background color in hex or rgba string, or "transparent". If not defined, it will use its `bgcolor` property as background color to clear the canvas.
         */
        clear(bg?: string): this;
        /**
         * Set a background color on the container element
        @param bg background color as hex or rgba string
         */
        background: string;
        /**
         * Add or update a style definition, and optionally update that style in the Element
         * @param key style name
         * @param val style value
         * @param update a boolean to update the element's style immediately if set to `true`. Default is `false`.
         */
        style(key: string, val: string, update?: boolean): this;
        /**
         * Add of update a list of style definitions, and optionally update those styles in the Element
         * @param styles a key-value objects of style definitions
         * @param update a boolean to update the element's style immediately if set to `true`. Default is `false`.
         * @return this
         */
        styles(styles: object, update?: boolean): this;
        /**
         * A static helper function to add or update Element attributes
         * @param elem Element to update
         * @param data an object with key-value pairs
         * @returns this DOM element
         */
        static setAttr(elem: Element, data: object): Element;
        /**
         * A static helper function to compose an inline style string from a object of styles
         * @param elem Element to update
         * @param data an object with key-value pairs
         * @exmaple DOMSpace.getInlineStyles( {width: "100px", "font-size": "10px"} ); // returns "width: 100px; font-size: 10px"
         */
        static getInlineStyles(data: object): string;
}
/**
    * HTMLSpace. Note that this is currently experimental and may change in future.
    */
export class HTMLSpace extends DOMSpace {
        /**
         * Get a new `HTMLForm` for drawing
         * @see `HTMLForm`
         */
        getForm(): Form;
        /**
            * A static function to add a DOM element inside a node. Usually you don't need to use this directly. See methods in `DOMForm` instead.
            * @param parent the parent element, or `null` to use current `<svg>` as parent.
            * @param name a string of element name,  such as `rect` or `circle`
            * @param id id attribute of the new element
            * @param autoClass add a class based on the id (from char 0 to index of "-"). Default is true.
            */
        static htmlElement(parent: Element, name: string, id?: string, autoClass?: boolean): HTMLElement;
        /**
         * Remove an item from this Space
         * @param item a player item with an auto-assigned `animateID` property
         */
        remove(player: IPlayer): this;
        /**
            * Remove all items from this Space
            */
        removeAll(): this;
}
/**
    * Form for HTMLSpace. Note that this is currently experimental and may change in future.
    */
export class HTMLForm extends VisualForm {
        protected _ctx: DOMFormContext;
        static groupID: number;
        static domID: number;
        protected _space: HTMLSpace;
        protected _ready: boolean;
        constructor(space: HTMLSpace);
        readonly space: HTMLSpace;
        /**
            * Update a style in _ctx context or throw an Erorr if the style doesn't exist
            * @param k style key
            * @param v  style value
            * @param unit Optional unit like 'px' to append to value
            */
        protected styleTo(k: any, v: any, unit?: string): void;
        /**
         * Set current fill style. Provide a valid color string or `false` to specify no fill color.
         * @example `form.fill("#F90")`, `form.fill("rgba(0,0,0,.5")`, `form.fill(false)`
         * @param c fill color
         */
        fill(c: string | boolean): this;
        /**
         * Set current stroke style. Provide a valid color string or `false` to specify no stroke color.
         * @example `form.stroke("#F90")`, `form.stroke("rgba(0,0,0,.5")`, `form.stroke(false)`, `form.stroke("#000", 0.5, 'round', 'square')`
         * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle))
         * @param width Optional value (can be floating point) to set line width
         * @param linejoin not implemented in HTMLForm
         * @param linecap not implemented in HTMLForm
         */
        stroke(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
         * Set current text color style. Provide a valid color string.
         * @example `form.fill("#F90")`, `form.fill("rgba(0,0,0,.5")`, `form.fill(false)`
         * @param c fill color
         */
        fillText(c: string): this;
        /**
            * Add custom class to the created element
            * @param c custom class name or `false` to reset it
            * @example `form.fill("#f00").cls("myClass").rects(r)` `form.cls(false).circles(c)`
            */
        cls(c: string | boolean): this;
        /**
         * Set the current font
         * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties
         * @param weight Optional font-weight string such as "bold"
         * @param style Optional font-style string such as "italic"
         * @param lineHeight Optional line-height number suchas 1.5
         * @param family Optional font-family such as "Helvetica, sans-serif"
         * @example `form.font( myFont )`, `form.font(14, "bold")`
         */
        font(sizeOrFont: number | Font, weight?: string, style?: string, lineHeight?: number, family?: string): this;
        /**
         * Reset the context's common styles to this form's styles. This supports using multiple forms on the same canvas context.
         */
        reset(): this;
        /**
            * Set this form's group scope by an ID, and optionally define the group's parent element. A group scope keeps track of elements by their generated IDs, and updates their properties as needed. See also `scope()`.
            * @param group_id a string to use as prefix for the group's id. For example, group_id "hello" will create elements with id like "hello-1", "hello-2", etc
            * @param group Optional DOM element to define this group's parent element
            * @returns this form's context
            */
        updateScope(group_id: string, group?: Element): object;
        /**
            * Set the current group scope to an item added into space, in order to keep track of any point, circle, etc created within it. The item must have an `animateID` property, so that elements created within the item will have generated IDs like "item-{animateID}-{count}".
            * @param item a "player" item that's added to space (see `space.add(...)`) and has an `animateID` property
            * @returns this form's context
            */
        scope(item: IPlayer): object;
        /**
            * Get next available id in the current group
            * @returns an id string
            */
        nextID(): string;
        /**
            * A static function to generate an ID string based on a context object
            * @param ctx a context object for an HTMLForm
            */
        static getID(ctx: any): string;
        /**
            * A static function to generate an ID string for a scope, based on a "player" item in the Space
            * @param item a "player" item that's added to space (see `space.add(...)`) and has an `animateID` property
            */
        static scopeID(item: IPlayer): string;
        /**
            * A static function to help adding style object to an element. This put all styles into `style` attribute instead of individual attributes, so that the styles can be parsed by Adobe Illustrator.
            * @param elem A DOM element to add to
            * @param styles an object of style properties
            * @example `HTMLForm.style(elem, {fill: "#f90", stroke: false})`
            * @returns DOM element
            */
        static style(elem: Element, styles: object): Element;
        /**
        * A helper function to set top, left, width, height of DOM element
        * @param x left position
        * @param y top position
        * @param w width
        * @param h height
        */
        static rectStyle(ctx: DOMFormContext, pt: PtLike, size: PtLike): DOMFormContext;
        /**
         * Draws a point
         * @param ctx a context object of HTMLForm
         * @param pt a Pt object or numeric array
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         * @example `HTMLForm.point( p )`, `HTMLForm.point( p, 10, "circle" )`
         */
        static point(ctx: DOMFormContext, pt: PtLike, radius?: number, shape?: string): Element;
        /**
         * Draws a point
         * @param p a Pt object
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         * @example `form.point( p )`, `form.point( p, 10, "circle" )`
         */
        point(pt: PtLike, radius?: number, shape?: string): this;
        /**
         * A static function to draw a circle
         * @param ctx a context object of HTMLForm
         * @param pt center position of the circle
         * @param radius radius of the circle
         */
        static circle(ctx: DOMFormContext, pt: PtLike, radius?: number): Element;
        /**
         * Draw a circle
         * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]
         * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)
         */
        circle(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw a square
         * @param ctx a context object of HTMLForm
         * @param pt center position of the square
         * @param halfsize half size of the square
         */
        static square(ctx: DOMFormContext, pt: PtLike, halfsize: number): HTMLElement;
        /**
            * Draw a square, given a center and its half-size
            * @param pt center Pt
            * @param halfsize half-size
            */
        square(pt: PtLike, halfsize: number): this;
        /**
         * A static function to draw a rectangle
         * @param ctx a context object of HTMLForm
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        static rect(ctx: DOMFormContext, pts: GroupLike | number[][]): Element;
        /**
         * Draw a rectangle
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        rect(pts: number[][] | Pt[]): this;
        /**
         * A static function to draw text
         * @param ctx a context object of HTMLForm
         * @param `pt` a Point object to specify the anchor point
         * @param `txt` a string of text to draw
         * @param `maxWidth` specify a maximum width per line
         */
        static text(ctx: DOMFormContext, pt: PtLike, txt: string): Element;
        /**
         * Draw text on canvas
         * @param `pt` a Pt or numeric array to specify the anchor point
         * @param `txt` text
         * @param `maxWidth` specify a maximum width per line
         */
        text(pt: PtLike, txt: string): this;
        /**
         * A convenient way to draw some text on canvas for logging or debugging. It'll be draw on the top-left of the canvas as an overlay.
         * @param txt text
         */
        log(txt: any): this;
        /**
            * Arc is not implemented in HTMLForm
            */
        arc(pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): this;
        /**
            * Line is not implemented in HTMLForm
            */
        line(pts: GroupLike | number[][]): this;
        /**
            * Polygon is not implemented in HTMLForm
            * @param pts
            */
        polygon(pts: GroupLike | number[][]): this;
}

/**
 * Form is an abstract class that represents a form that's used in a Space for expressions.
 */
export abstract class Form {
        protected _ready: boolean;
        /**
         * get whether the Form has received the Space's rendering context
         */
        readonly ready: boolean;
        /**
            * Check number of items in a Group against a required number
            * @param pts
            */
        static _checkSize(pts: GroupLike | number[][], required?: number): boolean;
}
/**
 * VisualForm is an abstract class that represents a form that can be used to express Pts visually.
 * For example, CanvasForm is an implementation of VisualForm that draws on CanvasSpace which represents a html canvas.
 */
export abstract class VisualForm extends Form {
        protected _filled: boolean;
        filled: boolean;
        protected _stroked: boolean;
        stroked: boolean;
        protected _font: Font;
        readonly currentFont: Font;
        protected _multiple(groups: GroupLike[], shape: string, ...rest: any[]): this;
        /**
         * Abstract reset style
         */
        abstract reset(): this;
        /**
         * Set fill color (not implemented)
         */
        fill(c: string | boolean): this;
        /**
         * Set current fill style and without stroke.
         * @example `form.fillOnly("#F90")`, `form.fillOnly("rgba(0,0,0,.5")`
         * @param c fill color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle))
         */
        fillOnly(c: string | boolean): this;
        /**
         * Set stroke style (not implemented)
         */
        stroke(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
         * Set current stroke style and without fill.
         * @example `form.strokeOnly("#F90")`, `form.strokeOnly("#000", 0.5, 'round', 'square')`
         * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle)
         */
        strokeOnly(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
         * Abstract point drawing
         * @param p a Pt object
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         * @example `form.point( p )`, `form.point( p, 10, "circle" )`
         */
        abstract point(p: PtLike, radius: number, shape: string): this;
        /**
         * Draw multiple points at once
         * @param pts an array of Pt or an array of number arrays
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         */
        points(pts: GroupLike | number[][], radius: number, shape: string): this;
        /**
         * Abstract circle drawing
         * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]
         * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)
         */
        abstract circle(pts: GroupLike | number[][]): this;
        /**
         * Draw multiple circles at once
         * @param groups an array of Groups that defines multiple circles
         */
        circles(groups: GroupLike[]): this;
        /**
         * Draw multiple squares at once
         * @param groups an array of Groups that defines multiple circles
         */
        squares(groups: GroupLike[]): this;
        /**
         * Abstract arc drawing
         * @param pt center position
         * @param radius radius of the arc circle
         * @param startAngle start angle of the arc
         * @param endAngle end angle of the arc
         * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
         */
        abstract arc(pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): this;
        /**
         * Abstract a line or polyline drawing
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        abstract line(pts: GroupLike | number[][]): this;
        /**
         * Draw multiple lines at once
         * @param groups An array of Groups of Pts
         */
        lines(groups: GroupLike[]): this;
        /**
         * Abstract polygon drawing
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        abstract polygon(pts: GroupLike | number[][]): this;
        /**
         * Draw multiple polygons at once
         * @param groups An array of Groups of Pts
         */
        polygons(groups: GroupLike[]): this;
        /**
         * Abstract rectangle drawing
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        abstract rect(pts: number[][] | Pt[]): this;
        /**
         * Draw multiple rectangles at once
         * @param groups An array of Groups of Pts
         */
        rects(groups: GroupLike[]): this;
        /**
         * Abstract text rendering
         * @param `pt` a Pt or numeric array to specify the anchor point
         * @param `txt` text
         * @param `maxWidth` specify a maximum width per line
         */
        abstract text(pt: PtLike, txt: string, maxWidth?: number): this;
        /**
         * Abstract font setting
         * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties
         * @param weight Optional font-weight string such as "bold"
         * @param style Optional font-style string such as "italic"
         * @param lineHeight Optional line-height number suchas 1.5
         * @param family Optional font-family such as "Helvetica, sans-serif"
         * @see `Font` class
         * @example `form.font( myFont )`, `form.font(14, "bold")`
         */
        abstract font(sizeOrFont: number | Font, weight?: string, style?: string, lineHeight?: number, family?: string): this;
}
/**
 * Font class lets you create a specific font style with properties for its size and style
 */
export class Font {
        size: number;
        lineHeight: number;
        face: string;
        style: string;
        weight: string;
        /**
         * Create a font style
         * @param size font size. Defaults is 12px.
         * @param face Optional font-family, use css-like string such as "Helvetica" or "Helvetica, sans-serif". Default is "sans-serif".
         * @param weight Optional font weight such as "bold". Default is "" (none).
         * @param style Optional font style such as "italic". Default is "" (none).
         * @param lineHeight Optional line height. Default is 1.5.
         * @example `new Font(12, "Frutiger, sans-serif", "bold", "underline", 1.5)`
         */
        constructor(size?: number, face?: string, weight?: string, style?: string, lineHeight?: number);
        /**
         * Get a string representing the font style, in css-like string such as "italic bold 12px/1.5 sans-serif"
         */
        readonly value: string;
        /**
         * Get a string representing the font style, in css-like string such as "italic bold 12px/1.5 sans-serif"
         */
        toString(): string;
}

/**
    * Vec provides static function for vector operations. It's not yet optimized but good enough to use.
    */
export class Vec {
        /**
            * Add b to vector `a`
            * @returns vector `a`
            */
        static add(a: PtLike, b: PtLike | number): PtLike;
        /**
            * Subtract `b` from vector `a`
            * @returns vector `a`
            */
        static subtract(a: PtLike, b: PtLike | number): PtLike;
        /**
            * Multiply `b` with vector `a`
            * @returns vector `a`
            */
        static multiply(a: PtLike, b: PtLike | number): PtLike;
        /**
            * Divide `a` over `b`
            * @returns vector `a`
            */
        static divide(a: PtLike, b: PtLike | number): PtLike;
        /**
            * Dot product of `a` and `b`
            */
        static dot(a: PtLike, b: PtLike): number;
        /**
            * 2D cross product of `a` and `b`
            */
        static cross2D(a: PtLike, b: PtLike): number;
        /**
            * 3D Cross product of `a` and `b`
            */
        static cross(a: PtLike, b: PtLike): Pt;
        /**
            * Magnitude of `a`
            */
        static magnitude(a: PtLike): number;
        /**
            * Unit vector of `a`. If magnitude of `a` is already known, pass it in the second paramter to optimize calculation.
            */
        static unit(a: PtLike, magnitude?: number): PtLike;
        /**
            * Set `a` to its absolute value in each dimension
            * @returns vector `a`
            */
        static abs(a: PtLike): PtLike;
        /**
            * Set `a` to its floor value in each dimension
            * @returns vector `a`
            */
        static floor(a: PtLike): PtLike;
        /**
            * Set `a` to its ceiling value in each dimension
            * @returns vector `a`
            */
        static ceil(a: PtLike): PtLike;
        /**
            * Set `a` to its rounded value in each dimension
            * @returns vector `a`
            */
        static round(a: PtLike): PtLike;
        /**
            * Find the max value within a vector's dimensions
            * @returns an object with `value` and `index` that specifies the max value and its corresponding dimension.
            */
        static max(a: PtLike): {
                value;
                index;
        };
        /**
            * Find the min value within a vector's dimensions
            * @returns an object with `value` and `index` that specifies the min value and its corresponding dimension.
            */
        static min(a: PtLike): {
                value;
                index;
        };
        /**
            * Sum all the dimensions' values
            */
        static sum(a: PtLike): number;
        /**
            * Given a mapping function, update `a`'s value in each dimension
            * @returns vector `a`
            */
        static map(a: PtLike, fn: (n: number, index: number, arr) => number): PtLike;
}
/**
    * Mat provides static function for matrix operations. It's not yet optimized but good enough to use.
    */
export class Mat {
        /**
            * Matrix additions. Matrices should have the same rows and columns.
            * @param a a group of Pt
            * @param b a scalar number, an array of numeric arrays, or a group of Pt
            * @returns a group with the same rows and columns as a and b
            */
        static add(a: GroupLike, b: GroupLike | number[][] | number): Group;
        /**
            * Matrix multiplication
            * @param a a Group of M Pts, each with K dimensions (M-rows, K-columns)
            * @param b a scalar number, an array of numeric arrays, or a Group of K Pts, each with N dimensions (K-rows, N-columns) -- or if transposed is true, then N Pts with K dimensions
            * @param transposed (Only applicable if it's not elementwise multiplication) If true, then a and b's columns should match (ie, each Pt should have the same dimensions). Default is `false`.
            * @param elementwise if true, then the multiplication is done element-wise. Default is `false`.
            * @returns If not elementwise, this will return a group with M Pt, each with N dimensions (M-rows, N-columns).
            */
        static multiply(a: GroupLike, b: GroupLike | number[][] | number, transposed?: boolean, elementwise?: boolean): Group;
        /**
            * Zip one slice of an array of Pt. Imagine the Pts are organized in rows, then this function will take the values in a specific column.
            * @param g a group of Pt
            * @param idx index to zip at
            * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.
            */
        static zipSlice(g: GroupLike | number[][], index: number, defaultValue?: number | boolean): Pt;
        /**
            * Zip a group of Pt. eg, [[1,2],[3,4],[5,6]] => [[1,3,5],[2,4,6]]
            * @param g a group of Pt
            * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.
            * @param useLongest If true, find the longest list of values in a Pt and use its length for zipping. Default is false, which uses the first item's length for zipping.
            */
        static zip(g: GroupLike | number[][], defaultValue?: number | boolean, useLongest?: boolean): Group;
        /**
            * Same as `zip` function
            */
        static transpose(g: GroupLike | number[][], defaultValue?: number | boolean, useLongest?: boolean): Group;
        /**
            * Transform a 2D point given a 2x3 or 3x3 matrix
            * @param pt a Pt to be transformed
            * @param m 2x3 or 3x3 matrix
            * @returns a new transformed Pt
            */
        static transform2D(pt: PtLike, m: GroupLike | number[][]): Pt;
        /**
            * Get a scale matrix for use in `transform2D`
            */
        static scale2DMatrix(x: number, y: number): GroupLike;
        /**
            * Get a rotate matrix for use in `transform2D`
            */
        static rotate2DMatrix(cosA: number, sinA: number): GroupLike;
        /**
            * Get a shear matrix for use in `transform2D`
            */
        static shear2DMatrix(tanX: number, tanY: number): GroupLike;
        /**
            * Get a translate matrix for use in `transform2D`
            */
        static translate2DMatrix(x: number, y: number): GroupLike;
        /**
            * Get a matrix to scale a point from an origin point. For use in `transform2D`
            */
        static scaleAt2DMatrix(sx: number, sy: number, at: PtLike): GroupLike;
        /**
            * Get a matrix to rotate a point from an origin point. For use in `transform2D`
            */
        static rotateAt2DMatrix(cosA: number, sinA: number, at: PtLike): GroupLike;
        /**
            * Get a matrix to shear a point from an origin point. For use in `transform2D`
            */
        static shearAt2DMatrix(tanX: number, tanY: number, at: PtLike): GroupLike;
        /**
            * Get a matrix to reflect a point along a line. For use in `transform2D`
            * @param p1 first end point to define the reflection line
            * @param p1 second end point to define the reflection line
            */
        static reflectAt2DMatrix(p1: PtLike, p2: PtLike): Pt[];
}

/**
    * Num class provides various helper functions for basic numeric operations
    */
export class Num {
        /**
            * Check if two numbers are equal or almost equal within a threshold
            * @param a number a
            * @param b number b
            * @param threshold a threshold within which the two numbers are considered equal
            */
        static equals(a: number, b: number, threshold?: number): boolean;
        /**
            * Linear interpolation
            * @param a start value
            * @param b end value
            * @param t usually a value between 0 to 1
            */
        static lerp(a: number, b: number, t: number): number;
        /**
            * Clamp values between min and max
            * @param val value to clamp
            * @param min min value
            * @param max max value
            */
        static clamp(val: number, min: number, max: number): number;
        /**
            * Different from Num.clamp in that the value out-of-bound will be "looped back" to the other end.
            * @param val value to bound
            * @param min min value
            * @param max max value
            * @example `boundValue(361, 0, 360)` will return 1
            */
        static boundValue(val: number, min: number, max: number): number;
        /**
            * Check if a value is within
            * @param p
            * @param a
            * @param b
            */
        static within(p: number, a: number, b: number): boolean;
        /**
            * Get a random number within a range
            * @param a range value 1
            * @param b range value 2
            */
        static randomRange(a: number, b?: number): number;
        /**
            * Normalize a value within a range
            * @param n the value to normalize
            * @param a range value 1
            * @param b range value 1
            */
        static normalizeValue(n: number, a: number, b: number): number;
        /**
            * Sum a group of numeric arrays
            * @param pts an array of numeric arrays
            * @returns a array of sums
            */
        static sum(pts: GroupLike | number[][]): Pt;
        /**
            * Sum a group of numeric arrays
            * @param pts an array of numeric arrays
            * @returns a array of sums
            */
        static average(pts: GroupLike | number[][]): Pt;
        /**
            * Given a value between 0 to 1, returns a value that cycles between 0 -> 1 -> 0 using sine method.
            * @param t a value between 0 to 1
            * @return a value between 0 to 1
            */
        static cycle(t: number): number;
        /**
            * Map a value from one range to another
            * @param n a value in the first range
            * @param currMin lower bound of the first range
            * @param currMax upper bound of the first range
            * @param targetMin lower bound of the second range
            * @param targetMax upper bound of the second range
            * @returns a remapped value in the second range
            */
        static mapToRange(n: number, currA: any, currB: any, targetA: any, targetB: any): number;
}
/**
    * Geom class provides various helper functions for basic geometric operations
    */
export class Geom {
        /**
            * Bound an angle between 0 to 360 degrees
            */
        static boundAngle(angle: number): number;
        /**
            * Bound a radian between 0 to 2-PI
            */
        static boundRadian(angle: number): number;
        /**
            * Convert an angle in degree to radian
            */
        static toRadian(angle: number): number;
        /**
            * Convert an angle in radian to degree
            */
        static toDegree(radian: number): number;
        /**
            * Get a bounding box for a set of Pts
            * @param pts a Group or an array of Pts
            * @return a Group of two Pts, representing the top-left and bottom-right corners.
            */
        static boundingBox(pts: GroupLike): Group;
        /**
            * Get a centroid (the average middle point) for a set of Pts
            * @param pts a Group or an array of Pts
            * @return a centroid Pt
            */
        static centroid(pts: GroupLike | number[][]): Pt;
        /**
            * Given an anchor Pt, rebase all Pts in this group either to or from this anchor base.
            * @param pts a Group or array of Pt
            * @param ptOrIndex an index for the Pt array, or an external Pt
            * @param direction "to" (subtract all Pt with this anchor base) or "from" (add all Pt from this anchor base)
            */
        static anchor(pts: GroupLike, ptOrIndex?: PtLike | number, direction?: ("to" | "from")): void;
        /**
            * Get an interpolated (or extrapolated) value between two Pts
            * @param a first Pt
            * @param b second Pt
            * @param t a value between 0 to 1 to interpolate, or any other value to extrapolate
            * @returns interpolated point as a new Pt
            */
        static interpolate(a: Pt | number[], b: Pt | number[], t?: number): Pt;
        /**
            * Find two Pt that are perpendicular to this Pt (2D)
            * @param axis a string such as "xy" (use Const.xy) or an array to specify index for two dimensions
            * @returns an array of two Pt that are perpendicular to this Pt
            */
        static perpendicular(pt: PtLike, axis?: string | number[]): Group;
        /**
            * Check if two Pts (vectors) are perpendicular to each other
            */
        static isPerpendicular(p1: PtLike, p2: PtLike): boolean;
        /**
            * Check if a Pt is within the rectangular boundary defined by two Pts
            * @param pt the Pt to check
            * @param boundPt1 boundary Pt 1
            * @param boundPt2 boundary Pt 2
            */
        static withinBound(pt: PtLike | number[], boundPt1: PtLike | number[], boundPt2: PtLike | number[]): boolean;
        /**
            * Sort the Pts so that their edges will form a non-overlapping polygon
            * Ref: https://stackoverflow.com/questions/6989100/sort-points-in-clockwise-order
            * @param pts an array of Pts
            */
        static sortEdges(pts: GroupLike): GroupLike;
        /**
            * Scale a Pt or a Group of Pts
            * @param ps a Pt or a Group of Pts
            * @param scale scale value
            * @param anchor optional anchor point to scale from
            */
        static scale(ps: Pt | GroupLike, scale: number | number[] | PtLike, anchor?: PtLike): Geom;
        /**
            * Rotate a Pt or a Group of Pts in 2D space
            * @param ps a Pt or a Group of Pts
            * @param angle rotate angle
            * @param anchor optional anchor point to rotate from
            * @param axis optional axis such as "yz" to define a 2D plane of rotation
            */
        static rotate2D(ps: Pt | GroupLike, angle: number, anchor?: PtLike, axis?: string): Geom;
        /**
            * Shear a Pt or a Group of Pts in 2D space
            * @param ps a Pt or a Group of Pts
            * @param scale shearing value which can be a number or an array of 2 numbers
            * @param anchor optional anchor point to shear from
            * @param axis optional axis such as "yz" to define a 2D plane of shearing
            */
        static shear2D(ps: Pt | GroupLike, scale: number | number[] | PtLike, anchor?: PtLike, axis?: string): Geom;
        /**
            * Reflect a Pt or a Group of Pts along a 2D line
            * @param ps a Pt or a Group of Pts
            * @param line a Group of 2 Pts that defines a line for reflection
            * @param axis optional axis such as "yz" to define a 2D plane of reflection
            */
        static reflect2D(ps: Pt | GroupLike, line: GroupLike, axis?: string): Geom;
        /**
            * Generate a sine and cosine lookup table
            * @returns an object with 2 tables (array of 360 values) and 2 functions to get sin/cos given a radian parameter. { sinTable:Float64Array, cosTable:Float64Array, sin:(rad)=>number, cos:(rad)=>number }
            */
        static cosTable(): {
                table: Float64Array;
                cos: (rad: number) => number;
        };
        /**
            * Generate a sine and cosine lookup table
            * @returns an object with 2 tables (array of 360 values) and 2 functions to get sin/cos given a radian parameter. { sinTable:Float64Array, cosTable:Float64Array, sin:(rad)=>number, cos:(rad)=>number }
            */
        static sinTable(): {
                table: Float64Array;
                sin: (rad: number) => number;
        };
}
/**
    * Shaping provides various shaping/easing functions to interpolate a value non-linearly.
    */
export class Shaping {
        /**
            * Linear mapping
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static linear(t: number, c?: number): number;
        /**
            * Quadratic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
         */
        static quadraticIn(t: number, c?: number): number;
        /**
            * Quadratic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
         */
        static quadraticOut(t: number, c?: number): number;
        /**
            * Quadratic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static quadraticInOut(t: number, c?: number): number;
        /**
            * Cubic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static cubicIn(t: number, c?: number): number;
        /**
            * Cubic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static cubicOut(t: number, c?: number): number;
        /**
            * Cubic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static cubicInOut(t: number, c?: number): number;
        /**
            * Exponential ease In, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p a value between 0 to 1 to control the curve. Default is 0.25.
            */
        static exponentialIn(t: number, c?: number, p?: number): number;
        /**
            * Exponential ease out, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p a value between 0 to 1 to control the curve. Default is 0.25.
            */
        static exponentialOut(t: number, c?: number, p?: number): number;
        /**
            * Sinuous in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static sineIn(t: number, c?: number): number;
        /**
            * Sinuous out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static sineOut(t: number, c?: number): number;
        /**
            * Sinuous in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static sineInOut(t: number, c?: number): number;
        /**
            * A faster way to approximate cosine ease in-out using Blinn-Wyvill Approximation. Adapated from Golan Levin's [polynomial shaping](http://www.flong.com/texts/code/shapers_poly/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static cosineApprox(t: number, c?: number): number;
        /**
            * Circular in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static circularIn(t: number, c?: number): number;
        /**
            * Circular out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static circularOut(t: number, c?: number): number;
        /**
            * Circular in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static circularInOut(t: number, c?: number): number;
        /**
            * Elastic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.
            */
        static elasticIn(t: number, c?: number, p?: number): number;
        /**
            * Elastic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.
            */
        static elasticOut(t: number, c?: number, p?: number): number;
        /**
            * Elastic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.6.
            */
        static elasticInOut(t: number, c?: number, p?: number): number;
        /**
            * Bounce in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static bounceIn(t: number, c?: number): number;
        /**
            * Bounce out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static bounceOut(t: number, c?: number): number;
        /**
            * Bounce in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static bounceInOut(t: number, c?: number): number;
        /**
            * Sigmoid curve changes its shape adapted from the input value, but always returns a value between 0 to 1.
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p the larger the value, the "steeper" the curve will be. Default is 10.
            */
        static sigmoid(t: number, c?: number, p?: number): number;
        /**
            * The Logistic Sigmoid is a useful curve. Adapted from Golan Levin's [shaping function](http://www.flong.com/texts/code/shapers_exp/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.7.
            */
        static logSigmoid(t: number, c?: number, p?: number): number;
        /**
            * An exponential seat curve. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.5.
            */
        static seat(t: number, c?: number, p?: number): number;
        /**
            * Quadratic bezier curve. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p1 a Pt object specifying the first control Pt, or a value specifying the control Pt's x position (its y position will default to 0.5). Default is `Pt(0.95, 0.95)
            */
        static quadraticBezier(t: number, c?: number, p?: number | PtLike): number;
        /**
            * Cubic bezier curve. This reuses the bezier functions in Curve class.
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p1` a Pt object specifying the first control Pt. Default is `Pt(0.1, 0.7).
            * @parma p2` a Pt object specifying the second control Pt. Default is `Pt(0.9, 0.2).
            */
        static cubicBezier(t: number, c?: number, p1?: PtLike, p2?: PtLike): number;
        /**
            * Give a Pt, draw a quadratic curve that will pass through that Pt as closely as possible. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_poly/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p1` a Pt object specifying the Pt to pass through. Default is `Pt(0.2, 0.35)
            */
        static quadraticTarget(t: number, c?: number, p1?: PtLike): number;
        /**
            * Step function is a simple jump from 0 to 1 at a specific Pt in time
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p usually a value between 0 to 1, which specify the Pt to "jump". Default is 0.5 which is in the middle.
            */
        static cliff(t: number, c?: number, p?: number): number;
        /**
            * Convert any shaping functions into a series of steps
            * @parma fn the original shaping function
            * @parma steps the number of steps
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma args optional paramters to pass to original function
            */
        static step(fn: Function, steps: number, t: number, c: number, ...args: any[]): any;
}
/**
    * Range object keeps track of a Group of n-dimensional Pts to provide its minimum, maximum, and magnitude in each dimension.
    * It also provides convenient functions such as mapping the Group to another range.
    */
export class Range {
        protected _source: Group;
        protected _max: Pt;
        protected _min: Pt;
        protected _mag: Pt;
        protected _dims: number;
        /**
            * Construct a Range instance for a Group of Pts,
            * @param g a Group or an array of Pts
            */
        constructor(g: GroupLike);
        /**
            * Get this Range's maximum values per dimension
            */
        readonly max: Pt;
        /**
            * Get this Range's minimum values per dimension
            */
        readonly min: Pt;
        /**
            * Get this Range's magnitude in each dimension
            */
        readonly magnitude: Pt;
        /**
            * Go through the group and find its min and max values.
            * Usually you don't need to call this function directly.
            */
        calc(): this;
        /**
            * Map this Range to another range of values
            * @param min target range's minimum value
            * @param max target range's maximum value
            * @param exclude Optional boolean array where `true` means excluding the conversion in that specific dimension.
            */
        mapTo(min: number, max: number, exclude?: boolean[]): Group;
        /**
            * Add more Pts to this Range and recalculate its min and max values
            * @param g a Group or an array of Pts to append to this Range
            * @param update Optional. Set the parameter to `false` if you want to append without immediately updating this Range's min and max values. Default is `true`.
            */
        append(g: GroupLike, update?: boolean): this;
        /**
            * Create a number of evenly spaced "ticks" that span this Range's min and max value.
            * @param count number of subdivision. For example, 10 subdivision will return 11 tick values, which include first(min) and last(max) values.
            */
        ticks(count: number): Group;
}

export type IntersectContext = {
        which: number;
        dist: number;
        normal: Pt;
        vertex: Pt;
        edge: Group;
        other?: any;
};
/**
    * Line class provides static functions to create and operate on lines. A line is usually represented as a Group of 2 Pts.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
export class Line {
        /**
            * Create a line by "drawing" from an anchor point, given an angle and a magnitude
            * @param anchor an anchor Pt
            * @param angle an angle in radian
            * @param magnitude magnitude of the line
            * @return a Group of 2 Pts representing a line segement
            */
        static fromAngle(anchor: PtLike, angle: number, magnitude: number): Group;
        /**
            * Calculate the slope of a line
            * @param p1 line's first end point
            * @param p2 line's second end point
            */
        static slope(p1: PtLike | number[], p2: PtLike | number[]): number;
        /**
            * Calculate the slope and xy intercepts of a line
            * @param p1 line's first end point
            * @param p2 line's second end point
            * @returns an object with `slope`, `xi`, `yi` properties
            */
        static intercept(p1: PtLike | number[], p2: PtLike | number[]): {
                slope: number;
                xi: number;
                yi: number;
        };
        /**
            * Given a 2D path and a point, find whether the point is on left or right side of the line
            * @param line  a Group of at least 2 Pts
            * @param pt a Pt
            * @returns a negative value if on left and a positive value if on right. If collinear, then the return value is 0.
            */
        static sideOfPt2D(line: GroupLike, pt: PtLike): number;
        /**
            * Check if three Pts are collinear, ie, on the same straight path.
            * @param p1 first Pt
            * @param p2 second Pt
            * @param p3 third Pt
            * @param threshold a threshold where a smaller value means higher precision threshold for the straight line. Default is 0.01.
            */
        static collinear(p1: PtLike | number[], p2: PtLike | number[], p3: PtLike | number[], threshold?: number): boolean;
        /**
            * Get magnitude of a line segment
            * @param line a Group of at least 2 Pts
            */
        static magnitude(line: GroupLike): number;
        /**
            * Get squared magnitude of a line segment
            * @param line a Group of at least 2 Pts
            */
        static magnitudeSq(line: GroupLike): number;
        /**
            * Find a point on a line that is perpendicular (shortest distance) to a target point
            * @param pt a target Pt
            * @param ln a group of Pts that defines a line
            * @param asProjection if true, this returns the projection vector instead. Default is false.
            * @returns a Pt on the line that is perpendicular to the target Pt, or a projection vector if `asProjection` is true.
            */
        static perpendicularFromPt(line: GroupLike, pt: PtLike | number[], asProjection?: boolean): Pt;
        /**
            * Given a line and a point, find the shortest distance from the point to the line
            * @param line a Group of 2 Pts
            * @param pt a Pt
            * @see `Line.perpendicularFromPt`
            */
        static distanceFromPt(line: GroupLike, pt: PtLike | number[]): number;
        /**
            * Given two lines as rays (infinite lines), find their intersection point if any.
            * @param la a Group of 2 Pts representing a ray
            * @param lb a Group of 2 Pts representing a ray
            * @returns an intersection Pt or undefined if no intersection
            */
        static intersectRay2D(la: GroupLike, lb: GroupLike): Pt;
        /**
            * Given two line segemnts, find their intersection point if any.
            * @param la a Group of 2 Pts representing a line segment
            * @param lb a Group of 2 Pts representing a line segment
            * @returns an intersection Pt or undefined if no intersection
            */
        static intersectLine2D(la: GroupLike, lb: GroupLike): Pt;
        /**
            * Given a line segemnt and a ray (infinite line), find their intersection point if any.
            * @param line a Group of 2 Pts representing a line segment
            * @param ray a Group of 2 Pts representing a ray
            * @returns an intersection Pt or undefined if no intersection
            */
        static intersectLineWithRay2D(line: GroupLike, ray: GroupLike): Pt;
        /**
            * Given a line segemnt and a ray (infinite line), find its intersection point(s) with a polygon.
            * @param lineOrRay a Group of 2 Pts representing a line or ray
            * @param poly a Group of Pts representing a polygon
            * @param sourceIsRay a boolean value to treat the line as a ray (infinite line). Default is `false`.
            */
        static intersectPolygon2D(lineOrRay: GroupLike, poly: GroupLike, sourceIsRay?: boolean): Group;
        /**
            * Find intersection points of 2 polygons. This checks all line segments in the two lists. Consider using a bounding-box check before calling this.
            * @param lines1 an array of line segments
            * @param lines2 an array of line segments
            * @param isRay a boolean value to treat the line as a ray (infinite line). Default is `false`.
            */
        static intersectLines2D(lines1: GroupLike[], lines2: GroupLike[], isRay?: boolean): Group;
        /**
            * Get two intersection Pts of a ray with a 2D grid point
            * @param ray a ray specified by 2 Pts
            * @param gridPt a Pt on the grid
            * @returns a group of two intersecting Pts. The first one is horizontal intersection and the second one is vertical intersection.
            */
        static intersectGridWithRay2D(ray: GroupLike, gridPt: PtLike | number[]): Group;
        /**
            * Get two intersection Pts of a line segment with a 2D grid point
            * @param ray a ray specified by 2 Pts
            * @param gridPt a Pt on the grid
            * @returns a group of two intersecting Pts. The first one is horizontal intersection and the second one is vertical intersection.
            */
        static intersectGridWithLine2D(line: GroupLike, gridPt: PtLike | number[]): Group;
        /**
            * Quick way to check rectangle intersection.
            * For more optimized implementation, store the rectangle's sides separately (eg, `Rectangle.sides()`) and use `Polygon.intersectPolygon2D()`.
            * @param line a Group representing a line
            * @param rect a Group representing a rectangle
            * @returns a Group of intersecting Pts
            */
        static intersectRect2D(line: GroupLike, rect: GroupLike): Group;
        /**
            * Get evenly distributed points on a line
            * @param line a Group representing a line
            * @param num number of points to get
            */
        static subpoints(line: GroupLike | number[][], num: number): Group;
        /**
            * Crop this line by a circle or rectangle at end point.
            * @param line line to crop
            * @param size size of circle or rectangle as Pt
            * @param index line's end point index, ie, 0 = start and 1 = end.
            * @param cropAsCircle a boolean to specify whether the `size` parameter should be treated as circle. Default is `true`.
            * @return an intersecting point on the line that can be used for cropping.
            */
        static crop(line: GroupLike, size: PtLike, index?: number, cropAsCircle?: boolean): Pt;
        /**
            * Create an marker arrow or line, placed at an end point of this line
            * @param line line to place marker
            * @param size size of the marker as Pt
            * @param graphic either "arrow" or "line"
            * @param atTail a boolean, if `true`, the marker will be positioned at tail of the line (ie, index = 1). Default is `true`.
            * @returns a Group that defines the marker's shape
            */
        static marker(line: GroupLike, size: PtLike, graphic?: string, atTail?: boolean): Group;
        /**
            * Convert this line to a rectangle representation
            * @param line a Group representing a line
            */
        static toRect(line: GroupLike): Group;
}
/**
    * Rectangle class provides static functions to create and operate on rectangles. A rectangle is usually represented as a Group of 2 Pts, marking the top-left and bottom-right corners of the rectangle.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
export class Rectangle {
        /**
            * Same as `Rectangle.fromTopLeft`
            */
        static from(topLeft: PtLike | number[], widthOrSize: number | PtLike, height?: number): Group;
        /**
            * Create a rectangle given a top-left position and a size
            * @param topLeft top-left point
            * @param widthOrSize width as a number, or a Pt that defines its size
            * @param height optional height as a number
            */
        static fromTopLeft(topLeft: PtLike | number[], widthOrSize: number | PtLike, height?: number): Group;
        /**
            * Create a rectangle given a center position and a size
            * @param topLeft top-left point
            * @param widthOrSize width as a number, or a Pt that defines its size
            * @param height optional height as a number
            */
        static fromCenter(center: PtLike | number[], widthOrSize: number | PtLike, height?: number): Group;
        /**
            * Convert this rectangle to a circle that fits within the rectangle
            * @returns a Group that represents a circle
            * @see `Circle`
            */
        static toCircle(pts: GroupLike): Group;
        /**
            * Create a square that either fits within or encloses a rectangle
            * @param pts a Group of 2 Pts representing a rectangle
            * @param enclose if `true`, the square will enclose the rectangle. Default is `false`, which will fit the square inside the rectangle.
            */
        static toSquare(pts: GroupLike, enclose?: boolean): Group;
        /**
            * Get the size of this rectangle as a Pt
            * @param pts a Group of 2 Pts representing a Rectangle
            */
        static size(pts: GroupLike): Pt;
        /**
            * Get the center of this rectangle
            * @param pts a Group of 2 Pts representing a Rectangle
            */
        static center(pts: GroupLike): Pt;
        /**
            * Get the 4 corners of this rectangle as a Group
            * @param rect a Group of 2 Pts representing a Rectangle
            */
        static corners(rect: GroupLike): Group;
        /**
            * Get the 4 sides of this rectangle as an array of 4 Groups
            * @param rect a Group of 2 Pts representing a Rectangle
            * @returns an array of 4 Groups, each of which represents a line segment
            */
        static sides(rect: GroupLike): Group[];
        /**
            * Same as `Rectangle.sides`
            */
        static lines(rect: GroupLike): Group[];
        /**
            * Given an array of rectangles, get a rectangle that bounds all of them
            * @param rects an array of Groups that represent rectangles
            * @returns the bounding rectangle as a Group
            */
        static boundingBox(rects: GroupLike[]): Group;
        /**
            * Convert this rectangle into a Group representing a polygon
            * @param rect a Group of 2 Pts representing a Rectangle
            */
        static polygon(rect: GroupLike): Group;
        /**
            * Subdivide a rectangle into 4 rectangles, one for each quadrant
            * @param rect a Group of 2 Pts representing a Rectangle
            * @returns an array of 4 Groups of rectangles
            */
        static quadrants(rect: GroupLike, center?: PtLike): Group[];
        /**
            * Subdivde a rectangle into 2 rectangles, by row or by column
            * @param rect Group of 2 Pts representing a Rectangle
            * @param ratio a value between 0 to 1 to indicate the split ratio
            * @param asRows if `true`, split into 2 rows. Default is `false` which splits into 2 columns.
            * @returns an array of 2 Groups of rectangles
            */
        static halves(rect: GroupLike, ratio?: number, asRows?: boolean): Group[];
        /**
            * Check if a point is within a rectangle
            * @param rect a Group of 2 Pts representing a Rectangle
            * @param pt the point to check
            */
        static withinBound(rect: GroupLike, pt: PtLike): boolean;
        /**
            * Check if a rectangle is within the bounds of another rectangle
            * @param rect1 a Group of 2 Pts representing a rectangle
            * @param rect2 a Group of 2 Pts representing a rectangle
            * @param resetBoundingBox if `true`, reset the bounding box. Default is `false` which assumes the rect's first Pt at is its top-left corner.
            */
        static hasIntersectRect2D(rect1: GroupLike, rect2: GroupLike, resetBoundingBox?: boolean): boolean;
        /**
            * Quick way to check rectangle intersection.
            * For more optimized implementation, store the rectangle's sides separately (eg, `Rectangle.sides()`) and use `Polygon.intersectPolygon2D()`.
            * @param rect1 a Group of 2 Pts representing a rectangle
            * @param rect2 a Group of 2 Pts representing a rectangle
            */
        static intersectRect2D(rect1: GroupLike, rect2: GroupLike): Group;
}
/**
    * Circle class provides static functions to create and operate on circles. A circle is usually represented as a Group of 2 Pts, where the first Pt specifies the center, and the second Pt specifies the radius.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
export class Circle {
        /**
            * Create a circle that either fits within or encloses a rectangle
            * @param pts a Group of 2 Pts representing a rectangle
            * @param enclose if `true`, the circle will enclose the rectangle. Default is `false`, which will fit the circle inside the rectangle.
            */
        static fromRect(pts: GroupLike, enclose?: boolean): Group;
        /**
            * Create a circle based on a center point and a radius
            * @param pt center point of circle
            * @param radius radius of circle
            */
        static fromCenter(pt: PtLike, radius: number): Group;
        /**
            * Check if a point is within a circle
            * @param pts a Group of 2 Pts representing a circle
            * @param pt the point to checks
            * @param threshold an optional small number to set threshold. Default is 0.
            */
        static withinBound(pts: GroupLike, pt: PtLike, threshold?: number): boolean;
        /**
            * Get the intersection points between a circle and a ray (infinite line)
            * @param pts a Group of 2 Pts representing a circle
            * @param ray a Group of 2 Pts representing a ray
            * @returns a Group of intersection points, or an empty Group if no intersection is found
            */
        static intersectRay2D(pts: GroupLike, ray: GroupLike): Group;
        /**
            * Get the intersection points between a circle and a line segment
            * @param pts a Group of 2 Pts representing a circle
            * @param ray a Group of 2 Pts representing a line
            * @returns a Group of intersection points, or an empty Group if no intersection is found
            */
        static intersectLine2D(pts: GroupLike, line: GroupLike): Group;
        /**
            * Get the intersection points between two circles
            * @param pts a Group of 2 Pts representing a circle
            * @param circle a Group of 2 Pts representing a circle
            * @returns a Group of intersection points, or an empty Group if no intersection is found
            */
        static intersectCircle2D(pts: GroupLike, circle: GroupLike): Group;
        /**
            * Quick way to check rectangle intersection with a circle.
            * For more optimized implementation, store the rectangle's sides separately (eg, `Rectangle.sides()`) and use `Polygon.intersectPolygon2D()`.
            * @param pts a Group of 2 Pts representing a circle
            * @param rect a Group of 2 Pts representing a rectangle
            * @returns a Group of intersection points, or an empty Group if no intersection is found
            */
        static intersectRect2D(pts: GroupLike, rect: GroupLike): Group;
        /**
            * Convert this cirlce to a rectangle that encloses this circle
            * @param pts a Group of 2 Pts representing a circle
            */
        static toRect(pts: GroupLike): Group;
        /**
            * Convert this cirlce to a rectangle that fits within this circle
            * @param pts a Group of 2 Pts representing a circle
            */
        static toInnerRect(pts: GroupLike): Group;
        /**
            * Convert this cirlce to a triangle that fits within this circle
            * @param pts a Group of 2 Pts representing a circle
            */
        static toInnerTriangle(pts: GroupLike): Group;
}
/**
    * Triangle class provides static functions to create and operate on trianges. A triange is usually represented as a Group of 3 Pts.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
export class Triangle {
        /**
            * Create a triangle from a rectangle. The triangle will be isosceles, with the bottom of the rectangle as its base.
            * @param rect a Group of 2 Pts representing a rectangle
            */
        static fromRect(rect: GroupLike): Group;
        /**
            * Create a triangle that fits within a circle
            * @param circle a Group of 2 Pts representing a circle
            */
        static fromCircle(circle: GroupLike): Group;
        /**
            * Create an equilateral triangle based on a center point and a size
            * @param pt the center point
            * @param size size is the magnitude of lines from center to the triangle's vertices, like a "radius".
            */
        static fromCenter(pt: PtLike, size: number): Group;
        /**
            * Get the medial, which is an inner triangle formed by connecting the midpoints of this triangle's sides
            * @param pts a Group of Pts
            * @returns a Group representing a medial triangle
            */
        static medial(pts: GroupLike): Group;
        /**
            * Given a point of the triangle, the opposite side is the side which the point doesn't touch.
            * @param pts a Group of Pts
            * @param index a Pt on the triangle group
            * @returns a Group that represents a line of the opposite side
            */
        static oppositeSide(pts: GroupLike, index: number): Group;
        /**
            * Get a triangle's altitude, which is a line from a triangle's point to its opposite side, and perpendicular to its opposite side.
            * @param pts a Group of Pts
            * @param index a Pt on the triangle group
            * @returns a Group that represents the altitude line
            */
        static altitude(pts: GroupLike, index: number): Group;
        /**
            * Get orthocenter, which is the intersection point of a triangle's 3 altitudes (the 3 lines that are perpendicular to its 3 opposite sides).
            * @param pts a Group of Pts
            * @returns the orthocenter as a Pt
            */
        static orthocenter(pts: GroupLike): Pt;
        /**
            * Get incenter, which is the center point of its inner circle, and also the intersection point of its 3 angle bisector lines (each of which cuts one of the 3 angles in half).
            * @param pts a Group of Pts
            * @returns the incenter as a Pt
            */
        static incenter(pts: GroupLike): Pt;
        /**
            * Get an interior circle, which is the largest circle completed enclosed by this triangle
            * @param pts a Group of Pts
            * @param center Optional parameter if the incenter is already known. Otherwise, leave it empty and the incenter will be calculated
            */
        static incircle(pts: GroupLike, center?: Pt): Group;
        /**
            * Get circumcenter, which is the intersection point of its 3 perpendicular bisectors lines ( each of which divides a side in half and is perpendicular to the side)
            * @param pts a Group of Pts
            * @returns the circumcenter as a Pt
            */
        static circumcenter(pts: GroupLike): Pt;
        /**
            * Get circumcenter, which is the intersection point of its 3 perpendicular bisectors lines ( each of which divides a side in half and is perpendicular to the side)
            * @param pts a Group of Pts
            * @param center Optional parameter if the circumcenter is already known. Otherwise, leave it empty and the circumcenter will be calculated
            */
        static circumcircle(pts: GroupLike, center?: Pt): Group;
}
/**
    * Polygon class provides static functions to create and operate on polygons. A polygon is usually represented as a Group of 3 or more Pts.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
export class Polygon {
        /**
            * Get the centroid of a polygon, which is the average of all its points.
            * @param pts a Group of Pts representing a polygon
            */
        static centroid(pts: GroupLike): Pt;
        /**
            * Create a rectangular polygon
            * @param center center point of the rectangle
            * @param widthOrSize width as number, or a Pt representing the size of the rectangle
            * @param height optional height
            */
        static rectangle(center: PtLike, widthOrSize: number | PtLike, height?: number): Group;
        static fromCenter(center: PtLike, radius: number, sides: number): Group;
        /**
            * Given a Group of Pts that defines a polygon, get one edge using an index
            * @param pts a Group
            * @param idx index of a Pt in the Group
            */
        static lineAt(pts: GroupLike, idx: number): Group;
        /**
            * Get the line segments in this polygon
            * @param pts a Group of Pts
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            * @returns an array of Groups which has 2 Pts in each group
            */
        static lines(pts: GroupLike, closePath?: boolean): Group[];
        /**
            * Get a new polygon group that is derived from midpoints in this polygon
            * @param pts a Group of Pts
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            * @param t a value between 0 to 1 for interpolation. Default to 0.5 which will get the middle point.
            */
        static midpoints(pts: GroupLike, closePath?: boolean, t?: number): Group;
        /**
            * Given a Pt in the polygon group, the adjacent sides are the two sides which the Pt touches.
            * @param pts a group of Pts
            * @param index the target Pt
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            */
        static adjacentSides(pts: GroupLike, index: number, closePath?: boolean): Group[];
        /**
            * Get a bisector which is a line that split between two sides of a polygon equally.
            * @param pts a group of Pts
            * @param index the Pt in the polygon to bisect from
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            * @returns a bisector Pt that's a normalized unit vector
            */
        static bisector(pts: GroupLike, index: number): Pt;
        /**
            * Find the perimeter of this polygon, ie, the lengths of its sides.
            * @param pts a group of Pts
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            * @returns an object with `total` length, and `segments` which is a Pt that stores each segment's length
            */
        static perimeter(pts: GroupLike, closePath?: boolean): {
                total: number;
                segments: Pt;
        };
        /**
            * Find the area of a *convex* polygon.
            * @param pts a group of Pts
            */
        static area(pts: GroupLike): any;
        /**
            * Get a convex hull of the point set using Melkman's algorithm
            * (Reference: http://geomalgorithms.com/a12-_hull-3.html)
            * @param pts a group of Pt
            * @param sorted a boolean value to indicate if the group is pre-sorted by x position. Default is false.
            * @returns a group of Pt that defines the convex hull polygon
            */
        static convexHull(pts: GroupLike, sorted?: boolean): Group;
        /**
            * Given a point in the polygon as an origin, get an array of lines that connect all the remaining points to the origin point.
            * @param pts a Group representing a polygon
            * @param originIndex the origin point's index in the polygon
            */
        static network(pts: GroupLike, originIndex?: number): Group[];
        /**
            * Given a target Pt, find a Pt in a Group that's nearest to it.
            * @param pts a Group of Pt
            * @param pt Pt to check
            * @returns an index in the pts indicating the nearest Pt, or -1 if none found
            */
        static nearestPt(pts: GroupLike, pt: PtLike): number;
        /**
            * Project axis (eg, for use in Separation Axis Theorem)
            * @param poly
            * @param unitAxis
            */
        static projectAxis(poly: GroupLike, unitAxis: Pt): Pt;
        /**
            * Check overlap dist from projected axis
            * @param poly1 first polygon
            * @param poly2 second polygon
            * @param unitAxis unit axis
            */
        protected static _axisOverlap(poly1: any, poly2: any, unitAxis: any): number;
        /**
            * Check if a Pt is inside a convex polygon
            * @param poly a Group of Pt defining a convex polygon
            * @param pt the Pt to check
            */
        static hasIntersectPoint(poly: GroupLike, pt: PtLike): boolean;
        /**
            * Check if a convex polygon and a circle has intersections using Separating Axis Theorem.
            * @param poly a Group representing a convex polygon
            * @param circle a Group representing a circle
            * @returns an `IntersectContext` object that stores the intersection info, or undefined if there's no intersection
            */
        static hasIntersectCircle(poly: GroupLike, circle: GroupLike): IntersectContext;
        /**
            * Check if two convex polygons has intersections using Separating Axis Theorem.
            * @param poly1 a Group representing a convex polygon
            * @param poly2 a Group representing a convex polygon
            * @return an `IntersectContext` object that stores the intersection info, or undefined if there's no intersection
            */
        static hasIntersectPolygon(poly1: GroupLike, poly2: GroupLike): IntersectContext;
        /**
            * Find intersection points of 2 polygons by checking every side of both polygons
            * @param poly1 a Group representing a polygon
            * @param poly2 another Group representing a polygon
            */
        static intersectPolygon2D(poly1: GroupLike, poly2: GroupLike): Group;
        /**
            * Get a bounding box for each polygon group, as well as a union bounding-box for all groups
            * @param polys an array of Groups, or an array of Pt arrays
            */
        static toRects(polys: GroupLike[]): GroupLike[];
}
/**
    * Curve class provides static functions to interpolate curves. A curve is usually represented as a Group of 3 control points.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
export class Curve {
        /**
            * Get a precalculated coefficients per step
            * @param steps number of steps
            */
        static getSteps(steps: number): Group;
        /**
            * Given an index for the starting position in a Pt group, get the control and/or end points of a curve segment
            * @param pts a group of Pt
            * @param index start index in `pts` array. Default is 0.
            * @param copyStart an optional boolean value to indicate if the start index should be used twice. Default is false.
            * @returns a group of 4 Pts
            */
        static controlPoints(pts: GroupLike, index?: number, copyStart?: boolean): Group;
        /**
            * Calulcate weighted sum to get the interpolated points
            * @param ctrls anchors
            * @param params parameters
            */
        static _calcPt(ctrls: GroupLike, params: PtLike): Pt;
        /**
            * Create a Catmull-Rom curve. Catmull-Rom is a kind of Cardinal curve with smooth-looking curve.
            * @param pts a group of anchor Pt
            * @param steps the number of line segments per curve. Defaults to 10 steps.
            * @returns a curve as a group of interpolated Pt
            */
        static catmullRom(pts: GroupLike, steps?: number): Group;
        /**
            * Interpolate to get a point on Catmull-Rom curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @return an interpolated Pt on the curve
            */
        static catmullRomStep(step: Pt, ctrls: GroupLike): Pt;
        /**
            * Create a Cardinal spline curve
            * @param pts a group of anchor Pt
            * @param steps the number of line segments per curve. Defaults to 10 steps.
            * @param tension optional value between 0 to 1 to specify a "tension". Default to 0.5 which is the tension for Catmull-Rom curve.
            * @returns a curve as a group of interpolated Pt
            */
        static cardinal(pts: GroupLike, steps?: number, tension?: number): Group;
        /**
            * Interpolate to get a point on Catmull-Rom curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @param tension optional value between 0 to 1 to specify a "tension". Default to 0.5 which is the tension for Catmull-Rom curve
            * @return an interpolated Pt on the curve
            */
        static cardinalStep(step: Pt, ctrls: GroupLike, tension?: number): Pt;
        /**
            * Create a Bezier curve. In a cubic bezier curve, the first and 4th anchors are end-points, and 2nd and 3rd anchors are control-points.
            * @param pts a group of anchor Pt
            * @param steps the number of line segments per curve. Defaults to 10 steps.
            * @returns a curve as a group of interpolated Pt
            */
        static bezier(pts: GroupLike, steps?: number): Group;
        /**
            * Interpolate to get a point on a cubic Bezier curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @return an interpolated Pt on the curve
            */
        static bezierStep(step: Pt, ctrls: GroupLike): Pt;
        /**
            * Create a B-spline curve
            * @param pts a group of anchor Pt
            * @param steps the number of line segments per curve. Defaults to 10 steps.
            * @param tension optional value between 0 to n to specify a "tension". Default is 1 which is the usual tension.
            * @returns a curve as a group of interpolated Pt
            */
        static bspline(pts: GroupLike, steps?: number, tension?: number): Group;
        /**
            * Interpolate to get a point on a B-spline curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @return an interpolated Pt on the curve
            */
        static bsplineStep(step: Pt, ctrls: GroupLike): Pt;
        /**
            * Interpolate to get a point on a B-spline curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @param tension optional value between 0 to n to specify a "tension". Default to 1 which is the usual tension.
            * @return an interpolated Pt on the curve
            */
        static bsplineTensionStep(step: Pt, ctrls: GroupLike, tension?: number): Pt;
}

/**
    * A `World` stores and manages `Body` and `Particle` for 2D physics simulation
    */
export class World {
        protected _gravity: Pt;
        protected _friction: number;
        protected _damping: number;
        protected _bound: Bound;
        protected _particles: Particle[];
        protected _bodies: Body[];
        protected _names: {
                p: {};
                b: {};
        };
        protected _drawParticles: (p: Particle, i: number) => void;
        protected _drawBodies: (p: Body, i: number) => void;
        /**
            * Create a `World` for 2D physics simulation
            * @param bound a rectangular bounding box defined by a Group
            * @param friction a value between 0 to 1 where 1 means no friction. Default is 1
            * @param gravity a number of a Pt to define gravitational force. Using a number is a shorthand to set `new Pt(0, n)`. Default is 0.
            */
        constructor(bound: Group, friction?: number, gravity?: PtLike | number);
        gravity: Pt;
        friction: number;
        damping: number;
        /**
            * Get the number of bodies
            */
        readonly bodyCount: number;
        /**
            * Get the number of particles
            */
        readonly particleCount: number;
        /**
            * Get a body in this world by index or string id
            * @param id numeric index of the body, or a string id that associates with it.
            */
        body(id: number | string): Body;
        /**
            * Get a particle in this world by index or string id
            * @param id numeric index of the particle, or a string id that associates with it.
            */
        particle(id: number): Particle;
        /**
            * Update this world one time step
            * @param ms change in time in milliseconds
            */
        update(ms: number): void;
        /**
            * Draw particles using the provided function
            * @param fn a function that draws particles passed in the parameters `(particles, index)`.
            */
        drawParticles(fn: (p: Particle, i: number) => void): void;
        /**
            * Draw bodies using the provided function
            * @param fn a function that draws bodies passed in the parameters `(bodies, index)`.
            */
        drawBodies(fn: (p: Body, i: number) => void): void;
        /**
            * Add a particle or body to this world.
            * @param p `Particle` or `Body` instance
            * @param name optional name, which can be referenced in `body()` or `particle()` function to retrieve this back.
            */
        add(p: Particle | Body, name?: string): this;
        /**
            * Remove either body or particle from this world. Support removing a range and negative index.
            * @param which Either "body" or "particle"
            * @param index Start index, which can be negative (where -1 is at index 0, -2 at index 1, etc)
            * @param count Number of items to remove. Default is 1.
            */
        remove(which: "body" | "particle", index: number, count?: number): this;
        /**
            * Static function to calculate edge constraints between 2 particles.
            * @param p1 particle 1
            * @param p2 particle 1
            * @param dist distance between particles
            * @param stiff stiffness between 0 to 1.
            * @param precise use precise distance calculation. Default is `false`.
            */
        static edgeConstraint(p1: Particle, p2: Particle, dist: number, stiff?: number, precise?: boolean): Particle;
        /**
            * Static function to calculate bounding box constraints.
            * @param p particle
            * @param rect bounding box defined by a Group
            * @param damping damping between 0 to 1, where 1 means no damping. Default is 0.75.
            */
        static boundConstraint(p: Particle, rect: Group, damping?: number): void;
        /**
            * Internal integrate function
            * @param p particle
            * @param dt time changed
            * @param prevDt previous change in time, optional
            */
        protected integrate(p: Particle, dt: number, prevDt?: number): Particle;
        /**
            * Internal function to update particles
            */
        protected _updateParticles(dt: number): void;
        /**
            * Internal function to update bodies
            */
        protected _updateBodies(dt: number): void;
}
/**
    * Particle is a Pt that has radius and mass. It's usually added into `World` to create physics simulations.
    */
export class Particle extends Pt {
        protected _mass: number;
        protected _radius: number;
        protected _force: Pt;
        protected _prev: Pt;
        protected _body: Body;
        protected _lock: boolean;
        protected _lockPt: Pt;
        /**
            * Create a particle
            * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        constructor(...args: any[]);
        mass: number;
        radius: number;
        /**
            * Get previous position
            */
        previous: Pt;
        /**
            * Get current accumulated force
            */
        force: Pt;
        /**
            * Get the body of this particle, if any.
            */
        body: Body;
        /**
            *
            */
        lock: boolean;
        /**
            * Get the change in position since last time step
            */
        readonly changed: Pt;
        /**
            * Set a new position, and update previous and lock states if needed.
            */
        position: Pt;
        /**
            * Set the size of this particle. This sets both the radius and the mass.
            * @param r `radius` value, and also set `mass` to the same value.
            */
        size(r: number): this;
        /**
            * Add to the accumulated force
            * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        addForce(...args: any[]): Pt;
        /**
            * Verlet integration
            * @param dt change in time
            * @param friction friction from 0 to 1, where 1 means no friction
            * @param lastDt optional last change in time
            */
        verlet(dt: number, friction: number, lastDt?: number): this;
        /**
            * Hit this particle with an impulse
            * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            * @example `hit(10, 20)`, `hit( new Pt(5, 9) )`
            */
        hit(...args: any[]): this;
        /**
            * Check and respoond to collisions between two particles
            * @param p2 another particle
            * @param damp damping value between 0 to 1, where 1 means no damping.
            */
        collide(p2: Particle, damp?: number): void;
        toString(): string;
}
/**
    * Body consists of a group of `Particles` and edge constraints. It is usually added into a `World` to create physics simulations
    */
export class Body extends Group {
        protected _cs: Array<number[]>;
        protected _stiff: number;
        protected _locks: {
                [index: string]: Particle;
        };
        protected _mass: number;
        /**
            * Create an empty Body, this is usually followed by `init` to populate the Body. Alternatively, use static function `fromGroup` to create and initate a body directly.
            */
        constructor();
        /**
            * Create and populate a body with a group of Pts.
            * @param list a group of Pts
            * @param stiff stiffness value from 0 to 1, where 1 is the most stiff. Default is 1.
            * @param autoLink Automatically create links between the Pts. This usually works for regular convex polygons. Default is true.
            * @param autoMass Automatically calculate the mass based on the area of the polygon. Default is true.
            */
        static fromGroup(list: GroupLike, stiff?: number, autoLink?: boolean, autoMass?: boolean): Body;
        /**
            * Initiate a body
            * @param list a group of Pts
            * @param stiff stiffness value from 0 to 1, where 1 is the most stiff. Default is 1.
            */
        init(list: GroupLike, stiff?: number): this;
        /**
            * Get mass of this body.
            */
        mass: number;
        /**
            * Automatically calculate `mass` to body's polygon area.
            */
        autoMass(): this;
        /**
            * Create a linked edge between two points
            * @param index1 first point by index
            * @param index2 first point by index
            * @param stiff optionally stiffness value between 0 to 1, where 1 is the most stiff.
            */
        link(index1: number, index2: number, stiff?: number): this;
        /**
            * Automatically create links for all the points to preserve the initial body shape. This usually works for regular convex polygon.
            * @param stiff optionally stiffness value between 0 to 1, where 1 is the most stiff.
            */
        linkAll(stiff: number): void;
        /**
            * Return a list of all the linked edges as line segments.
            * @returns an array of Groups, each of which represents an edge
            */
        linksToLines(): Group[];
        /**
            * Recalculate all edge constraints
            */
        processEdges(): void;
        /**
            * Check and respond to collisions between two bodies
            * @param b another body
            */
        processBody(b: Body): void;
        /**
            * Check and respond to collisions between this body and a particle
            * @param b a particle
            */
        processParticle(b: Particle): void;
}

export interface IPt {
        x?: number;
        y?: number;
        z?: number;
        w?: number;
}
export var PtBaseArray: Float32ArrayConstructor;
export type GroupLike = Group | Pt[];
export type PtLike = Pt | Float32Array | number[];
/**
    * Pt is a subclass of Float32Array with additional properties and functions to support vector and geometric calculations.
    * See [Pt guide](../../guide/Pt-0200.html) for details
    */
export class Pt extends PtBaseArray implements IPt, Iterable<number> {
        protected _id: string;
        /**
            * Create a Pt. If no parameter is provided, this will instantiate a Pt with 2 dimensions [0, 0].
            *
            * Note that `new Pt(3)` will only instantiate Pt with length of 3 (ie, same as `new Float32Array(3)` ). If you need a Pt with 1 dimension of value 3, use `new Pt([3])`.
            * @example `new Pt()`, `new Pt(1,2,3,4,5)`, `new Pt([1,2])`, `new Pt({x:0, y:1})`, `new Pt(pt)`
            * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        constructor(...args: any[]);
        static make(dimensions: number, defaultValue?: number, randomize?: boolean): Pt;
        id: string;
        x: number;
        y: number;
        z: number;
        w: number;
        /**
            * Clone this Pt
            */
        clone(): Pt;
        /**
            * Check if another Pt is equal to this Pt, within a threshold
            * @param p another Pt to compare with
            * @param threshold a threshold value within which the two Pts are considered equal. Default is 0.000001.
            */
        equals(p: PtLike, threshold?: number): boolean;
        /**
            * Update the values of this Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        to(...args: any[]): this;
        /**
            * Like `to()` but returns a new Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $to(...args: any[]): Pt;
        /**
            * Update the values of this Pt to point at a specific angle
            * @param radian target angle in radian
            * @param magnitude Optional magnitude if known. If not provided, it'll calculate and use this Pt's magnitude.
            * @param anchorFromPt If `true`, translate to new position from current position. Default is `false` which update the position from origin (0,0);
            */
        toAngle(radian: number, magnitude?: number, anchorFromPt?: boolean): this;
        /**
            * Create an operation using this Pt, passing this Pt into a custom function's first parameter. See the [Op guide](../../guide/Op-0400.html) for details.
            * For example: `let myOp = pt.op( fn ); let result = myOp( [1,2,3] );`
            * @param fn any function that takes a Pt as its first parameter
            * @returns a resulting function that takes other parameters required in `fn`
            */
        op(fn: (p1: PtLike, ...rest: any[]) => any): (...rest: any[]) => any;
        /**
            * This combines a series of operations into an array. See `op()` for details.
            * For example: `let myOps = pt.ops([fn1, fn2, fn3]); let results = myOps.map( (op) => op([1,2,3]) );`
            * @param fns an array of functions for `op`
            * @returns an array of resulting functions
            */
        ops(fns: ((p1: PtLike, ...rest: any[]) => any)[]): ((...rest: any[]) => any)[];
        /**
            * Take specific dimensional values from this Pt and create a new Pt
            * @param axis a string such as "xy" (use Const.xy) or an array to specify index for two dimensions
            */
        $take(axis: string | number[]): Pt;
        /**
            * Concatenate this Pt with addition dimensional values and return as a new Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $concat(...args: any[]): Pt;
        /**
            * Add scalar or vector values to this Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        add(...args: any[]): this;
        /**
            * Like `add`, but returns result as a new Pt
            */
        $add(...args: any[]): Pt;
        /**
            * Subtract scalar or vector values from this Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        subtract(...args: any[]): this;
        /**
            * Like `subtract`, but returns result as a new Pt
            */
        $subtract(...args: any[]): Pt;
        /**
            * Multiply scalar or vector values (as element-wise) with this Pt.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        multiply(...args: any[]): this;
        /**
            * Like `multiply`, but returns result as a new Pt
            */
        $multiply(...args: any[]): Pt;
        /**
            * Divide this Pt over scalar or vector values (as element-wise)
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        divide(...args: any[]): this;
        /**
            * Like `divide`, but returns result as a new Pt
            */
        $divide(...args: any[]): Pt;
        /**
            * Get the sqaured distance (magnitude) of this Pt from origin
            */
        magnitudeSq(): number;
        /**
            * Get the distance (magnitude) of this Pt from origin
            */
        magnitude(): number;
        /**
            * Convert to a unit vector, which is a normalized vector whose magnitude equals 1.
            * @param magnitude Optional: if the magnitude is known, pass it as a parameter to avoid duplicate calculation.
            */
        unit(magnitude?: number): Pt;
        /**
            * Get a unit vector from this Pt
            */
        $unit(magnitude?: number): Pt;
        /**
            * Dot product of this Pt and another Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        dot(...args: any[]): number;
        /**
            * 2D Cross product of this Pt and another Pt. Return results as a new Pt.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        cross2D(...args: any[]): number;
        /**
            * 3D Cross product of this Pt and another Pt. Return results as a new Pt.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $cross(...args: any[]): Pt;
        /**
            * Calculate vector projection of this Pt on another Pt.
            * @param p a list of numbers, an array of number, or an object with {x,y,z,w} properties
            * @returns the projection vector as a Pt
            */
        $project(...args: any[]): Pt;
        /**
            * Calculate scalar projection
            * @param p a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        projectScalar(...args: any[]): number;
        /**
            * Absolute values for all values in this pt
            */
        abs(): Pt;
        /**
            * Get a new Pt with absolute values of this Pt
            */
        $abs(): Pt;
        /**
            * Floor values for all values in this pt
            */
        floor(): Pt;
        /**
            * Get a new Pt with floor values of this Pt
            */
        $floor(): Pt;
        /**
            * Ceil values for all values in this pt
            */
        ceil(): Pt;
        /**
            * Get a new Pt with ceil values of this Pt
            */
        $ceil(): Pt;
        /**
            * Round values for all values in this pt
            */
        round(): Pt;
        /**
            * Get a new Pt with round values of this Pt
            */
        $round(): Pt;
        /**
            * Find the minimum value across all dimensions in this Pt
            * @returns an object with `value` and `index` which returns the minimum value and its dimensional index
            */
        minValue(): {
                value: number;
                index: number;
        };
        /**
            * Find the maximum value across all dimensions in this Pt
            * @returns an object with `value` and `index` which returns the maximum value and its dimensional index
            */
        maxValue(): {
                value: number;
                index: number;
        };
        /**
            * Get a new Pt that has the minimum dimensional values of this Pt and another Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $min(...args: any[]): Pt;
        /**
            * Get a new Pt that has the maximum dimensional values of this Pt and another Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $max(...args: any[]): Pt;
        /**
            * Get angle of this vector from origin
            * @param axis a string such as "xy" (use Const.xy) or an array to specify index for two dimensions
            */
        angle(axis?: string | number[]): number;
        /**
            * Get the angle between this and another Pt
            * @param p the other Pt
            * @param axis a string such as "xy" (use Const.xy) or an array to specify index for two dimensions
            */
        angleBetween(p: Pt, axis?: string | number[]): number;
        /**
            * Scale this Pt from origin or from an anchor point
            * @param scale scale ratio
            * @param anchor optional anchor point to scale from
            */
        scale(scale: number | number[] | PtLike, anchor?: PtLike): this;
        /**
            * Rotate this Pt from origin or from an anchor point in 2D
            * @param angle rotate angle
            * @param anchor optional anchor point to scale from
            * @param axis optional string such as "yz" to specify a 2D plane
            */
        rotate2D(angle: number, anchor?: PtLike, axis?: string): this;
        /**
            * Shear this Pt from origin or from an anchor point in 2D
            * @param shear shearing value which can be a number or an array of 2 numbers
            * @param anchor optional anchor point to scale from
            * @param axis optional string such as "yz" to specify a 2D plane
            */
        shear2D(scale: number | number[] | PtLike, anchor?: PtLike, axis?: string): this;
        /**
            * Reflect this Pt along a 2D line
            * @param line a Group of 2 Pts that defines a line for reflection
            * @param axis optional axis such as "yz" to define a 2D plane of reflection
            */
        reflect2D(line: GroupLike, axis?: string): this;
        /**
            * A string representation of this Pt: "Pt(1, 2, 3)"
            */
        toString(): string;
        /**
            * Convert this Pt to a javascript Array
            */
        toArray(): number[];
}
/**
    * A Group is a subclass of Array. It should onnly contain Pt instances. You can think of it as an array of arrays (Float32Arrays to be specific).
    * See [Group guide](../../guide/Group-0300.html) for details
    */
export class Group extends Array<Pt> {
        protected _id: string;
        constructor(...args: Pt[]);
        id: string;
        /** The first Pt in this group */
        readonly p1: Pt;
        /** The second Pt in this group */
        readonly p2: Pt;
        /** The third Pt in this group */
        readonly p3: Pt;
        /** The forth Pt in this group */
        readonly p4: Pt;
        /** The last Pt in this group */
        readonly q1: Pt;
        /** The second-last Pt in this group */
        readonly q2: Pt;
        /** The third-last Pt in this group */
        readonly q3: Pt;
        /** The forth-last Pt in this group */
        readonly q4: Pt;
        /**
            * Depp clone this group and its Pts
            */
        clone(): Group;
        /**
            * Convert an array of numeric arrays into a Group of Pts
            * @param list an array of numeric arrays
            * @example `Group.fromArray( [[1,2], [3,4], [5,6]] )`
            */
        static fromArray(list: PtLike[]): Group;
        /**
            * Convert an array of Pts into a Group.
            * @param list an array of Pts
            */
        static fromPtArray(list: GroupLike): Group;
        /**
            * Split this Group into an array of sub-groups
            * @param chunkSize number of items per sub-group
            * @param stride forward-steps after each sub-group
            * @param loopBack if `true`, always go through the array till the end and loop back to the beginning to complete the segments if needed
            */
        split(chunkSize: number, stride?: number, loopBack?: boolean): Group[];
        /**
            * Insert a Pt into this group
            * @param pts Another group of Pts
            * @param index the index position to insert into
            */
        insert(pts: GroupLike, index?: number): this;
        /**
            * Like Array's splice function, with support for negative index and a friendlier name.
            * @param index start index, which can be negative (where -1 is at index 0, -2 at index 1, etc)
            * @param count number of items to remove
            * @returns The items that are removed.
            */
        remove(index?: number, count?: number): Group;
        /**
            * Split this group into an array of sub-group segments
            * @param pts_per_segment number of Pts in each segment
            * @param stride forward-step to take
            * @param loopBack if `true`, always go through the array till the end and loop back to the beginning to complete the segments if needed
            */
        segments(pts_per_segment?: number, stride?: number, loopBack?: boolean): Group[];
        /**
            * Get all the line segments (ie, edges in a graph) of this group
            */
        lines(): Group[];
        /**
            * Find the centroid of this group's Pts, which is the average middle point.
            */
        centroid(): Pt;
        /**
            * Find the rectangular bounding box of this group's Pts.
            * @returns a Group of 2 Pts representing the top-left and bottom-right of the rectangle
            */
        boundingBox(): Group;
        /**
            * Anchor all the Pts in this Group using a target Pt as origin. (ie, subtract all Pt with the target anchor to get a relative position). All the Pts' values will be updated.
            * @param ptOrIndex a Pt, or a numeric index to target a specific Pt in this Group
            */
        anchorTo(ptOrIndex?: PtLike | number): void;
        /**
            * Anchor all the Pts in this Group by its absolute position from a target Pt. (ie, add all Pt with the target anchor to get an absolute position).  All the Pts' values will be updated.
            * @param ptOrIndex a Pt, or a numeric index to target a specific Pt in this Group
            */
        anchorFrom(ptOrIndex?: PtLike | number): void;
        /**
            * Create an operation using this Group, passing this Group into a custom function's first parameter.  See the [Op guide](../../guide/Op-0400.html) for details.
            * For example: `let myOp = group.op( fn ); let result = myOp( [1,2,3] );`
            * @param fn any function that takes a Group as its first parameter
            * @returns a resulting function that takes other parameters required in `fn`
            */
        op(fn: (g1: GroupLike, ...rest: any[]) => any): (...rest: any[]) => any;
        /**
            * This combines a series of operations into an array. See `op()` for details.
            * For example: `let myOps = pt.ops([fn1, fn2, fn3]); let results = myOps.map( (op) => op([1,2,3]) );`
            * @param fns an array of functions for `op`
            * @returns an array of resulting functions
            */
        ops(fns: ((g1: GroupLike, ...rest: any[]) => any)[]): ((...rest: any[]) => any)[];
        /**
            * Get an interpolated point on the line segments defined by this Group
            * @param t a value between 0 to 1 usually
            */
        interpolate(t: number): Pt;
        /**
            * Move every Pt's position by a specific amount. Same as `add`.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        moveBy(...args: any[]): this;
        /**
            * Move the first Pt in this group to a specific position, and move all the other Pts correspondingly
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        moveTo(...args: any[]): this;
        /**
            * Scale this group's Pts from an anchor point. Default anchor point is the first Pt in this group.
            * @param scale scale ratio
            * @param anchor optional anchor point to scale from
            */
        scale(scale: number | number[] | PtLike, anchor?: PtLike): this;
        /**
            * Rotate this group's Pt from an anchor point in 2D. Default anchor point is the first Pt in this group.
            * @param angle rotate angle
            * @param anchor optional anchor point to scale from
            * @param axis optional string such as "yz" to specify a 2D plane
            */
        rotate2D(angle: number, anchor?: PtLike, axis?: string): this;
        /**
            * Shear this group's Pt from an anchor point in 2D. Default anchor point is the first Pt in this group.
            * @param shear shearing value which can be a number or an array of 2 numbers
            * @param anchor optional anchor point to scale from
            * @param axis optional string such as "yz" to specify a 2D plane
            */
        shear2D(scale: number | number[] | PtLike, anchor?: PtLike, axis?: string): this;
        /**
            * Reflect this group's Pts along a 2D line. Default anchor point is the first Pt in this group.
            * @param line a Group of 2 Pts that defines a line for reflection
            * @param axis optional axis such as "yz" to define a 2D plane of reflection
            */
        reflect2D(line: GroupLike, axis?: string): this;
        /**
            * Sort this group's Pts by values in a specific dimension
            * @param dim dimensional index
            * @param desc if true, sort descending. Default is false (ascending)
            */
        sortByDimension(dim: number, desc?: boolean): this;
        /**
            * Update each Pt in this Group with a Pt function
            * @param ptFn string name of an existing Pt function. Note that the function must return Pt.
            * @param args arguments for the function specified in ptFn
            */
        forEachPt(ptFn: string, ...args: any[]): this;
        /**
            * Add scalar or vector values to this group's Pts.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        add(...args: any[]): this;
        /**
            * Subtract scalar or vector values from this group's Pts.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        subtract(...args: any[]): this;
        /**
            * Multiply scalar or vector values (as element-wise) with this group's Pts.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        multiply(...args: any[]): this;
        /**
            * Divide this group's Pts over scalar or vector values (as element-wise)
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        divide(...args: any[]): this;
        /**
            * Apply this group as a matrix and calculate matrix addition
            * @param g a scalar number, an array of numeric arrays, or a group of Pt
            * @returns a new Group
            */
        $matrixAdd(g: GroupLike | number[][] | number): Group;
        /**
            * Apply this group as a matrix and calculate matrix multiplication
            * @param g a scalar number, an array of numeric arrays, or a Group of K Pts, each with N dimensions (K-rows, N-columns) -- or if transposed is true, then N Pts with K dimensions
            * @param transposed (Only applicable if it's not elementwise multiplication) If true, then a and b's columns should match (ie, each Pt should have the same dimensions). Default is `false`.
            * @param elementwise if true, then the multiplication is done element-wise. Default is `false`.
            * @returns If not elementwise, this will return a new  Group with M Pt, each with N dimensions (M-rows, N-columns).
            */
        $matrixMultiply(g: GroupLike | number, transposed?: boolean, elementwise?: boolean): Group;
        /**
            * Zip one slice of an array of Pt. Imagine the Pts are organized in rows, then this function will take the values in a specific column.
            * @param idx index to zip at
            * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.
            */
        zipSlice(index: number, defaultValue?: number | boolean): Pt;
        /**
            * Zip a group of Pt. eg, [[1,2],[3,4],[5,6]] => [[1,3,5],[2,4,6]]
            * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.
            * @param useLongest If true, find the longest list of values in a Pt and use its length for zipping. Default is false, which uses the first item's length for zipping.
            */
        $zip(defaultValue?: number | boolean, useLongest?: boolean): Group;
        /**
            * Get a string representation of this group
            */
        toString(): string;
}

export type AnimateFunction = (time?: number, frameTime?: number, currentSpace?: any) => void;
/**
 * Interface of a "player" object that can be added into a Space
 */
export interface IPlayer {
        animateID?: string;
        animate?: AnimateFunction;
        resize?(size: IPt, evt?: Event): undefined;
        action?(type: string, px: number, py: number, evt: Event): any;
        start?(bound: Bound, space: Space): any;
}
export interface ISpacePlayers {
        [key: string]: IPlayer;
}
export interface ITimer {
        prev: number;
        diff: number;
        end: number;
}
/**
 * Space is an abstract class that represents a general context for expressing Pts.
 * See [Space guide](../../guide/Space-0500.html) for details.
 */
export abstract class Space {
        id: string;
        protected bound: Bound;
        protected _time: ITimer;
        protected players: ISpacePlayers;
        protected playerCount: number;
        protected _ctx: any;
        protected _pointer: Pt;
        protected _isReady: boolean;
        protected _playing: boolean;
        /**
         * Set whether the rendering should be repainted on each frame
         * @param b a boolean value to set whether to repaint each frame
         */
        refresh(b: boolean): this;
        /**
         * Add an IPlayer to this space. An IPlayer can define the following callback functions:
         * - `animate( time, ftime, space )`
         * - `start(bound, space)`
         * - `resize( size, event )`
         * - `action( type, x, y, event )`
         * Subclasses of Space may define other callback functions.
         * @param player an IPlayer object with animate function, or simply a function(time, ftime){}
         */
        add(p: IPlayer | AnimateFunction): this;
        /**
         * Remove a player from this Space
         * @param player an IPlayer that has an `animateID` property
         */
        remove(player: IPlayer): this;
        /**
         * Remove all players from this Space
         */
        removeAll(): this;
        /**
         * Main play loop. This implements window.requestAnimationFrame and calls it recursively.
         * Override this `play()` function to implemenet your own animation loop.
         * @param time current time
         */
        play(time?: number): this;
        /**
         * Replay the animation after `stop()`. This resets the end-time counter.
         * You may also use `pause()` and `resume()` for temporary pause.
         */
        replay(): void;
        /**
         * Main animate function. This calls all the items to perform
         * @param time current time
         */
        protected playItems(time: number): void;
        /**
         * Pause the animation
         * @param toggle a boolean value to set if this function call should be a toggle (between pause and resume)
         */
        pause(toggle?: boolean): this;
        /**
         * Resume the pause animation
         */
        resume(): this;
        /**
         * Specify when the animation should stop: immediately, after a time period, or never stops.
         * @param t a value in millisecond to specify a time period to play before stopping, or `-1` to play forever, or `0` to end immediately. Default is 0 which will stop the animation immediately.
         */
        stop(t?: number): this;
        /**
         * Play animation loop, and then stop after `duration` time has passed.
         * @param duration a value in millisecond to specify a time period to play before stopping, or `-1` to play forever
         */
        playOnce(duration?: number): this;
        /**
         * Custom rendering
         * @param context rendering context
         */
        protected render(context: any): this;
        /**
         * Set a custom rendering `function(graphics_context, canvas_space)` if needed
         */
        customRendering: (context: any, self: Space) => null;
        /**
            * Get a boolean to indicate whether the animation is playing
            */
        readonly isPlaying: boolean;
        /**
         * Get this space's bounding box
         */
        readonly outerBound: Bound;
        /**
         * The bounding box of the canvas
         */
        readonly innerBound: Bound;
        /**
         * Get the size of this bounding box as a Pt
         */
        readonly size: Pt;
        /**
         * Get the size of this bounding box as a Pt
         */
        readonly center: Pt;
        /**
         * Get width of canvas
         */
        readonly width: number;
        /**
         * Get height of canvas
         */
        readonly height: number;
        /**
         * Resize the space
         * @param w `width or an IPt object
         * @param h height
         */
        abstract resize(b: IPt, evt?: Event): this;
        /**
         * clear all contents in the space
         */
        abstract clear(): this;
        /**
         * Get a default form for drawing in this space
         */
        abstract getForm(): Form;
}
export type TouchPointsKey = "touches" | "changedTouches" | "targetTouches";
export interface MultiTouchElement {
        addEventListener(evt: any, callback: Function): any;
        removeEventListener(evt: any, callback: Function): any;
}
export abstract class MultiTouchSpace extends Space {
        protected _pressed: boolean;
        protected _dragged: boolean;
        protected _hasMouse: boolean;
        protected _hasTouch: boolean;
        protected _canvas: EventTarget;
        /**
         * Get the mouse or touch pointer that stores the last action
         */
        readonly pointer: Pt;
        /**
         * Bind event listener in canvas element. You can also use `bindMouse` or `bindTouch` to bind mouse or touch events conveniently.
         * @param evt an event string such as "mousedown"
         * @param callback callback function for this event
         */
        bindCanvas(evt: string, callback: EventListener): void;
        /**
         * Unbind a callback from the event listener
         * @param evt an event string such as "mousedown"
         * @param callback callback function to unbind
         */
        unbindCanvas(evt: string, callback: EventListener): void;
        /**
         * A convenient method to bind (or unbind) all mouse events in canvas element. All "players" added to this space that implements an `action` callback property will receive mouse event callbacks. The types of mouse actions are defined by UIPointerActions constants: "up", "down", "move", "drag", "drop", "over", and "out". See `Space`'s `add()` function for more details.
         * @param _bind a boolean value to bind mouse events if set to `true`. If `false`, all mouse events will be unbound. Default is true.
         * @see Space`'s [`add`](./_space_.space.html#add) function
         */
        bindMouse(_bind?: boolean): this;
        /**
         * A convenient method to bind (or unbind) all touch events in canvas element. All "players" added to this space that implements an `action` callback property will receive mouse event callbacks. The types of mouse actions are: "up", "down", "move", "drag", "drop", "over", and "out".
         * @param _bind a boolean value to bind touch events if set to `true`. If `false`, all mouse events will be unbound. Default is true.
         * @see Space`'s [`add`](./_space_.space.html#add) function
         */
        bindTouch(_bind?: boolean): this;
        /**
         * A convenient method to convert the touch points in a touch event to an array of `Pt`.
         * @param evt a touch event which contains touches, changedTouches, and targetTouches list
         * @param which a string to select a touches list: "touches", "changedTouches", or "targetTouches". Default is "touches"
         * @return an array of Pt, whose origin position (0,0) is offset to the top-left of this space
         */
        touchesToPoints(evt: TouchEvent, which?: TouchPointsKey): Pt[];
        /**
         * Go through all the `players` and call its `action` callback function
         * @param type an UIPointerActions constant or string: "up", "down", "move", "drag", "drop", "over", and "out"
         * @param evt mouse or touch event
         */
        protected _mouseAction(type: string, evt: MouseEvent | TouchEvent): void;
        /**
         * MouseDown handler
         * @param evt
         */
        protected _mouseDown(evt: MouseEvent | TouchEvent): boolean;
        /**
         * MouseUp handler
         * @param evt
         */
        protected _mouseUp(evt: MouseEvent | TouchEvent): boolean;
        /**
         * MouseMove handler
         * @param evt
         */
        protected _mouseMove(evt: MouseEvent | TouchEvent): boolean;
        /**
         * MouseOver handler
         * @param evt
         */
        protected _mouseOver(evt: MouseEvent | TouchEvent): boolean;
        /**
         * MouseOut handler
         * @param evt
         */
        protected _mouseOut(evt: MouseEvent | TouchEvent): boolean;
        /**
         * TouchMove handler
         * @param evt
         */
        protected _touchMove(evt: TouchEvent): boolean;
}

/**
    * A Space for SVG elements
    */
export class SVGSpace extends DOMSpace {
        id: string;
        protected _bgcolor: string;
        /**
         * Create a SVGSpace which represents a Space for SVG elements
         * @param elem Specify an element by its "id" attribute as string, or by the element object itself. An element can be an existing `<svg>`, or a `<div>` container in which a new `<svg>` will be created. If left empty, a `<div id="pt_container"><svg id="pt" /></div>` will be added to DOM. Use css to customize its appearance if needed.
         * @param callback an optional callback `function(boundingBox, spaceElement)` to be called when canvas is appended and ready. Alternatively, a "ready" event will also be fired from the `<svg>` element when it's appended, which can be traced with `spaceInstance.canvas.addEventListener("ready")`
         * @example `new SVGSpace( "#myElementID" )`
         */
        constructor(elem: string | Element, callback?: Function);
        /**
         * Get a new `SVGForm` for drawing
         * @see `SVGForm`
         */
        getForm(): SVGForm;
        /**
         * Get the html element
         */
        readonly element: Element;
        /**
         * This overrides Space's `resize` function. It's used as a callback function for window's resize event and not usually called directly. You can keep track of resize events with `resize: (bound ,evt)` callback in your player objects (See `Space`'s `add()` function).
         * @param b a Bound object to resize to
         * @param evt Optionally pass a resize event
         */
        resize(b: Bound, evt?: Event): this;
        /**
            * A static function to add a svg element inside a node. Usually you don't need to use this directly. See methods in `SVGForm` instead.
            * @param parent the parent element, or `null` to use current `<svg>` as parent.
            * @param name a string of element name,  such as `rect` or `circle`
            * @param id id attribute of the new element
            */
        static svgElement(parent: Element, name: string, id?: string): SVGElement;
        /**
         * Remove an item from this Space
         * @param item a player item with an auto-assigned `animateID` property
         */
        remove(player: IPlayer): this;
        /**
            * Remove all items from this Space
            */
        removeAll(): this;
}
/**
 * SVGForm is an implementation of abstract class VisualForm. It provide methods to express Pts on SVGSpace.
 * You may extend SVGForm to implement your own expressions for SVGSpace.
 */
export class SVGForm extends VisualForm {
        protected _ctx: DOMFormContext;
        static groupID: number;
        static domID: number;
        protected _space: SVGSpace;
        protected _ready: boolean;
        /**
         * Create a new SVGForm. You may also use `space.getForm()` to get the default form.
         * @param space an instance of SVGSpace
         */
        constructor(space: SVGSpace);
        /**
         * get the SVGSpace instance that this form is associated with
         */
        readonly space: SVGSpace;
        /**
            * Update a style in _ctx context or throw an Erorr if the style doesn't exist
            * @param k style key
            * @param v  style value
            */
        protected styleTo(k: any, v: any): void;
        /**
             * Set current fill style. Provide a valid color string or `false` to specify no fill color.
             * @example `form.fill("#F90")`, `form.fill("rgba(0,0,0,.5")`, `form.fill(false)`
             * @param c fill color
             */
        fill(c: string | boolean): this;
        /**
             * Set current stroke style. Provide a valid color string or `false` to specify no stroke color.
             * @example `form.stroke("#F90")`, `form.stroke("rgba(0,0,0,.5")`, `form.stroke(false)`, `form.stroke("#000", 0.5, 'round', 'square')`
             * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle))
             * @param width Optional value (can be floating point) to set line width
             * @param linejoin Optional string to set line joint style. Can be "miter", "bevel", or "round".
             * @param linecap Optional string to set line cap style. Can be "butt", "round", or "square".
             */
        stroke(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
            * Add custom class to the created element
            * @param c custom class name or `false` to reset it
            * @example `form.fill("#f00").cls("myClass").rects(r)` `form.cls(false).circles(c)`
            */
        cls(c: string | boolean): this;
        /**
         * Set the current font
         * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties
         * @param weight Optional font-weight string such as "bold"
         * @param style Optional font-style string such as "italic"
         * @param lineHeight Optional line-height number suchas 1.5
         * @param family Optional font-family such as "Helvetica, sans-serif"
         * @example `form.font( myFont )`, `form.font(14, "bold")`
         */
        font(sizeOrFont: number | Font, weight?: string, style?: string, lineHeight?: number, family?: string): this;
        /**
         * Reset the context's common styles to this form's styles. This supports using multiple forms on the same canvas context.
         */
        reset(): this;
        /**
            * Set this form's group scope by an ID, and optionally define the group's parent element. A group scope keeps track of elements by their generated IDs, and updates their properties as needed. See also `scope()`.
            * @param group_id a string to use as prefix for the group's id. For example, group_id "hello" will create elements with id like "hello-1", "hello-2", etc
            * @param group Optional DOM or SVG element to define this group's parent element
            * @returns this form's context
            */
        updateScope(group_id: string, group?: Element): object;
        /**
            * Set the current group scope to an item added into space, in order to keep track of any point, circle, etc created within it. The item must have an `animateID` property, so that elements created within the item will have generated IDs like "item-{animateID}-{count}".
            * @param item a "player" item that's added to space (see `space.add(...)`) and has an `animateID` property
            * @returns this form's context
            */
        scope(item: IPlayer): object;
        /**
            * Get next available id in the current group
            * @returns an id string
            */
        nextID(): string;
        /**
            * A static function to generate an ID string based on a context object
            * @param ctx a context object for an SVGForm
            */
        static getID(ctx: any): string;
        /**
            * A static function to generate an ID string for a scope, based on a "player" item in the Space
            * @param item a "player" item that's added to space (see `space.add(...)`) and has an `animateID` property
            */
        static scopeID(item: IPlayer): string;
        /**
            * A static function to help adding style object to an element. This put all styles into `style` attribute instead of individual attributes, so that the styles can be parsed by Adobe Illustrator.
            * @param elem A DOM element to add to
            * @param styles an object of style properties
            * @example `SVGForm.style(elem, {fill: "#f90", stroke: false})`
            * @returns this DOM element
            */
        static style(elem: SVGElement, styles: object): Element;
        /**
             * Draws a point
             * @param ctx a context object of SVGForm
             * @param pt a Pt object or numeric array
             * @param radius radius of the point. Default is 5.
             * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
             * @example `SVGForm.point( p )`, `SVGForm.point( p, 10, "circle" )`
             */
        static point(ctx: DOMFormContext, pt: PtLike, radius?: number, shape?: string): SVGElement;
        /**
             * Draws a point
             * @param p a Pt object
             * @param radius radius of the point. Default is 5.
             * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
             * @example `form.point( p )`, `form.point( p, 10, "circle" )`
             */
        point(pt: PtLike, radius?: number, shape?: string): this;
        /**
             * A static function to draw a circle
             * @param ctx a context object of SVGForm
             * @param pt center position of the circle
             * @param radius radius of the circle
             */
        static circle(ctx: DOMFormContext, pt: PtLike, radius?: number): SVGElement;
        /**
             * Draw a circle
             * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]
             * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)
             */
        circle(pts: GroupLike | number[][]): this;
        /**
             * A static function to draw an arc.
             * @param ctx a context object of SVGForm
             * @param pt center position
             * @param radius radius of the arc circle
             * @param startAngle start angle of the arc
             * @param endAngle end angle of the arc
             * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
             */
        static arc(ctx: DOMFormContext, pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): SVGElement;
        /**
             * Draw an arc.
             * @param pt center position
             * @param radius radius of the arc circle
             * @param startAngle start angle of the arc
             * @param endAngle end angle of the arc
             * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
             */
        arc(pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): this;
        /**
             * A static function to draw a square
             * @param ctx a context object of SVGForm
             * @param pt center position of the square
             * @param halfsize half size of the square
             */
        static square(ctx: DOMFormContext, pt: PtLike, halfsize: number): SVGElement;
        /**
            * Draw a square, given a center and its half-size
            * @param pt center Pt
            * @param halfsize half-size
            */
        square(pt: PtLike, halfsize: number): this;
        /**
         * A static function to draw a line
         * @param ctx a context object of SVGForm
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        static line(ctx: DOMFormContext, pts: GroupLike | number[][]): SVGElement;
        /**
         * Draw a line or polyline
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        line(pts: GroupLike | number[][]): this;
        /**
            * A static helper function to draw polyline or polygon
            * @param ctx a context object of SVGForm
            * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
            * @param closePath a boolean to specify if the polygon path should be closed
            */
        static _poly(ctx: DOMFormContext, pts: GroupLike | number[][], closePath?: boolean): SVGElement;
        /**
             * A static function to draw polygon
             * @param ctx a context object of SVGForm
             * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
             */
        static polygon(ctx: DOMFormContext, pts: GroupLike | number[][]): SVGElement;
        /**
         * Draw a polygon
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        polygon(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw a rectangle
         * @param ctx a context object of SVGForm
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        static rect(ctx: DOMFormContext, pts: GroupLike | number[][]): SVGElement;
        /**
             * Draw a rectangle
             * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
             */
        rect(pts: number[][] | Pt[]): this;
        /**
             * A static function to draw text
             * @param ctx a context object of SVGForm
             * @param `pt` a Point object to specify the anchor point
             * @param `txt` a string of text to draw
             * @param `maxWidth` specify a maximum width per line
             */
        static text(ctx: DOMFormContext, pt: PtLike, txt: string): SVGElement;
        /**
             * Draw text on canvas
             * @param `pt` a Pt or numeric array to specify the anchor point
             * @param `txt` text
             * @param `maxWidth` specify a maximum width per line
             */
        text(pt: PtLike, txt: string): this;
        /**
             * A convenient way to draw some text on canvas for logging or debugging. It'll be draw on the top-left of the canvas as an overlay.
             * @param txt text
             */
        log(txt: any): this;
}

/** Various functions to support typography */
export class Typography {
        /**
            * Create a heuristic text width estimate function. It will be less accurate but faster.
            * @param fn a reference function that can measure text width accurately
            * @param samples a list of string samples. Default is ["M", "n", "."]
            * @param distribution a list of the samples' probability distribution. Default is [0.06, 0.8, 0.14].
            * @return a function that can estimate text width
            */
        static textWidthEstimator(fn: (string) => number, samples?: string[], distribution?: number[]): (string) => number;
        /**
            * Truncate text to fit width
            * @param fn a function that can measure text width
            * @param str text to truncate
            * @param width width to fit
            * @param tail text to indicate overflow such as "...". Default is empty "".
            */
        static truncate(fn: (string) => number, str: string, width: number, tail?: string): [string, number];
        /**
            * Get a function to scale font size proportionally to text box size changes.
            * @param box Initial box as a Group
            * @param ratio font-size change ratio. Default is 1.
            * @returns a function where input parameter is a new box, and returns the new font size value
            */
        static fontSizeToBox(box: GroupLike, ratio?: number, byHeight?: boolean): (GroupLike) => number;
        /**
            * Get a function to scale font size based on a threshold value
            * @param defaultSize default font size to base on
            * @param threshold threshold value
            * @param direction if negative, get a font size <= defaultSize; if positive, get a font size >= defaultSize; Default is 0 which will scale font without min or max limits.
            * @returns a function where input parameter is the default font size and a value to compare with threshold, and returns new font size value
            */
        static fontSizeToThreshold(threshold: number, direction?: number): (a: number, b: number) => number;
}

/**
    * An enumeration of different UI types
    */
export enum UIShape {
        Rectangle = 0,
        Circle = 1,
        Polygon = 2,
        Polyline = 3,
        Line = 4,
}
export const UIPointerActions: {
        up: string;
        down: string;
        move: string;
        drag: string;
        drop: string;
        over: string;
        out: string;
};
/**
    * UIListener type
    */
export type UIHandler = (pt: Pt, target: UI, type: string) => void;
export class UI {
        group: Group;
        shape: UIShape;
        protected _id: string;
        protected _actions: {
                [key: string]: UIHandler;
        };
        protected _states: {
                [key: string]: any;
        };
        /**
            * Wrap an UI insider a group
            */
        constructor(group: Group, shape: UIShape, states: {}, id?: string);
        /**
            * Get and set uique id
            */
        id: string;
        /**
            * Get a state
            * @param key state's name
            */
        state(key: string): any;
        /**
            * Add an event handler
            * @param key event key
            * @param fn handler function
            */
        on(key: string, fn: UIHandler): this;
        /**
            * Remove an event handler
            * @param key even key
            * @param fn
            */
        off(key: string): this;
        /**
            * Listen for interactions and trigger action handlers
            * @param key action key
            * @param p point to check
            */
        listen(key: string, p: Pt): boolean;
        /**
            * Take a custom render function to render this UI
            * @param fn render function
            */
        render(fn: (group: Group, states: {
                [key: string]: any;
        }) => void): void;
        /**
            * Check intersection using a specific function based on UIShape
            * @param p a point to check
            */
        protected _trigger(p: Pt): boolean;
}
/**
    * A simple UI button that can track clicks and hovers
    */
export class UIButton extends UI {
        _clicks: number;
        constructor(group: Group, shape: UIShape, states: {}, id?: string);
        /**
            * Get the total number of clicks on this UIButton
            */
        readonly clicks: number;
        /**
            * Add a click handler
            * @param fn a function to handle clicks
            */
        onClick(fn: UIHandler): void;
        /**
            * Add hover handler
            * @param over a function to handle when pointer enters hover
            * @param out a function to handle when pointer exits hover
            */
        onHover(over: UIHandler, out: UIHandler): void;
}

/**
    * Various constant values for enumerations and calculations
    */
export const Const: {
        xy: string;
        yz: string;
        xz: string;
        xyz: string;
        horizontal: number;
        vertical: number;
        identical: number;
        right: number;
        bottom_right: number;
        bottom: number;
        bottom_left: number;
        left: number;
        top_left: number;
        top: number;
        top_right: number;
        epsilon: number;
        max: number;
        min: number;
        pi: number;
        two_pi: number;
        half_pi: number;
        quarter_pi: number;
        one_degree: number;
        rad_to_deg: number;
        deg_to_rad: number;
        gravity: number;
        newton: number;
        gaussian: number;
};
/**
    * Util provides various helper functions
    */
export class Util {
        static warnLevel: "error" | "warn" | "default";
        /**
            * Convert different kinds of parameters (arguments, array, object) into an array of numbers
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        static getArgs(args: any[]): Array<number>;
        /**
            * Send a warning message based on Util.warnLevel global setting. This allows you to dynamically set whether minor errors should be thrown or printed in console or muted.
            * @param message any error or warning message
            * @param defaultReturn optional return value
            */
        static warn(message?: string, defaultReturn?: any): any;
        static randomInt(range: number, start?: number): number;
        /**
            * Split an array into chunks of sub-array
            * @param pts an array
            * @param size chunk size, ie, number of items in a chunk
            * @param stride optional parameter to "walk through" the array in steps
            * @param loopBack if `true`, always go through the array till the end and loop back to the beginning to complete the segments if needed
            */
        static split(pts: any[], size: number, stride?: number, loopBack?: boolean): any[][];
        /**
            * Flatten an array of arrays such as Group[] to a flat Array or Group
            * @param pts an array, usually an array of Groups
            * @param flattenAsGroup a boolean to specify whether the return type should be a Group or Array. Default is `true` which returns a Group.
            */
        static flatten(pts: any[], flattenAsGroup?: boolean): any;
        /**
        * Given two arrays of object<T>, and a function that operate on two object<T>, return an array of T
        * @param a an array of object<T>, eg [ Group, Group, ... ]
        * @param b another array of object<T>
        * @param op a function that takes two parameters (a, b) and returns a T
        */
        static combine<T>(a: T[], b: T[], op: (a: T, b: T) => T): T[];
        /**
            * Zip arrays. eg, [[1,2],[3,4],[5,6]] => [[1,3,5],[2,4,6]]
            * @param arrays an array of arrays
            */
        static zip(...arrays: Array<any>[]): any[];
        /**
            * Create a convenient stepper. This returns a function which you can call repeatedly to step a counter.
            * @param max Maximum of the stepper range. The resulting stepper will return (min to max-1) values.
            * @param min Minimum of the stepper range. Default is 0.
            * @param stride Stride of the step. Default is 1.
            * @param callback An optional callback function( step ), which will be called each tiem when stepper function is called.
            * @example `let counter = stepper(100); let c = counter(); c = counter(); ...`
            * @returns a function which will increment the stepper and return its value at each call.
            */
        static stepper(max: number, min?: number, stride?: number, callback?: (n: number) => void): (() => number);
        /**
            * A convenient way to step through a range. Same as `for (i=0; i<range; i++)`, except this also stores the resulting return values at each step and return them as an array.
            * @param range a range to step through
            * @param fn a callback function(index). If this function returns a value, it will be stored at each step
            * @returns an array of returned values at each step
            */
        static forRange(fn: (index: number) => any, range: number, start?: number, step?: number): any[];
}

